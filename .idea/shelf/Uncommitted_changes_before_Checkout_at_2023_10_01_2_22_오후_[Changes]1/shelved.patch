Index: minjae/week3/BOJ_1520_내리막길.java
===================================================================
diff --git a/minjae/week3/BOJ_1520_내리막길.java b/minjae/week3/BOJ_1520_내리막길.java
deleted file mode 100644
--- a/minjae/week3/BOJ_1520_내리막길.java	
+++ /dev/null	
@@ -1,95 +0,0 @@
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.LinkedList;
-import java.util.Queue;
-import java.util.StringTokenizer;
-
-public class BOJ_1520_내리막길 {
-    static int N, M, sum;
-    static int Map[][], DP[][], delta[][] = { { 1, 0 }, { 0, 1 }, { 0, -1 }, { -1, 0 } };
-    static boolean Mcheck[][];
-
-    public static void main(String[] args) throws NumberFormatException, IOException {
-        // TODO Auto-generated method stub
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-
-        StringTokenizer st = null;
-
-        st = new StringTokenizer(br.readLine());
-        sum = 0;
-        N = Integer.parseInt(st.nextToken());
-        M = Integer.parseInt(st.nextToken());
-        Map = new int[N][M];
-        DP = new int[N][M];
-
-        for (int i = 0; i < N; i++) {
-            st = new StringTokenizer(br.readLine());
-            for (int j = 0; j < M; j++) {
-                Map[i][j] = Integer.parseInt(st.nextToken());
-                DP[i][j] = -1;
-            }
-        }
-
-
-        System.out.println(dfs(0, 0));
-
-//			bfs();
-//			System.out.println(sum);
-
-    }
-
-    static public void bfs() {
-        Queue<int[]> que = new LinkedList<>(); // 지나오는 길은 높이가 높아서 되돌아갈수 없으니 경로 체크 안함
-        que.add(new int[] { 0, 0 });
-
-        while (!que.isEmpty()) {
-            int current[] = que.poll();
-            int x = current[0];
-            int y = current[1];
-
-            if (x == N - 1 && y == M - 1) { // 마지막 지점에 도착시 갯수 + 1
-                sum++;
-            }
-
-            for (int i = 0; i < 4; i++) {
-                int nextX = x + delta[i][0];
-                int nextY = y + delta[i][1];
-
-                if (nextX >= 0 && nextX < N && nextY >= 0 && nextY < M && Map[x][y] > Map[nextX][nextY]) {
-                    que.add(new int[] { nextX, nextY });
-                }
-
-            }
-
-        }
-    }
-
-    static public int dfs(int x, int y) {
-
-        if (x == N - 1 && y == M - 1) { // 마지막 지점에 도착시 갯수 + 1
-            return 1;
-        }
-
-        if (DP[x][y] != -1)
-            return DP[x][y];
-
-        DP[x][y] = 0;
-        for (int i = 0; i < 4; i++) {
-            int nextX = x + delta[i][0];
-            int nextY = y + delta[i][1];
-
-            if (nextX >= 0 && nextX < N && nextY >= 0 && nextY < M && Map[x][y] > Map[nextX][nextY]) {
-                // 범위 안에서 아직 안가본 조건에 맞는 아직 가지 않은 경로 탐색
-
-                DP[x][y] += dfs(nextX, nextY);
-
-            }
-
-        }
-
-        return DP[x][y];
-
-    }
-
-}
\ No newline at end of file
Index: minjae/week2/BOJ_2470_두용액.java
===================================================================
diff --git a/minjae/week2/BOJ_2470_두용액.java b/minjae/week2/BOJ_2470_두용액.java
deleted file mode 100644
--- a/minjae/week2/BOJ_2470_두용액.java	
+++ /dev/null	
@@ -1,52 +0,0 @@
-package week2;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-public class BOJ_2470_두용액 {
-    static int N, M, tree[];
-
-    public static void main(String[] args) throws IOException {
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-
-        N = Integer.parseInt(br.readLine());
-        StringTokenizer st = new StringTokenizer(br.readLine());
-        int Map[] = new int [N];
-
-        for(int i= 0 ; i < N ; i++){
-            Map[i] = Integer.parseInt(st.nextToken());
-        }
-
-        Arrays.sort(Map);
-
-        int left = 0;
-        int right = Map.length -1;
-
-        int f = 0;
-        int k = 0;
-
-        int min = Integer.MAX_VALUE;
-        while(left < right){
-            int sum = Map[left] + Map[right];
-            int temp = Math.abs(sum);
-
-            if(temp < min){
-                min = temp;
-                f = Map[left];
-                k = Map[right];
-            }
-
-            if(sum > 0){
-                right--;
-            }else{
-                left++;
-            }
-
-        }
-        System.out.println(f + " " + k);
-
-    }
-
-}
\ No newline at end of file
Index: chansik/src/week06/BOJ_2504_괄호의값.java
===================================================================
diff --git a/chansik/src/week06/BOJ_2504_괄호의값.java b/chansik/src/week06/BOJ_2504_괄호의값.java
deleted file mode 100644
--- a/chansik/src/week06/BOJ_2504_괄호의값.java	
+++ /dev/null	
@@ -1,63 +0,0 @@
-package chansik.src.week06;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.Arrays;
-import java.util.Stack;
-
-public class BOJ_2504_괄호의값 {
-    static class Node {
-        private char word;
-        private int index;
-
-        public Node(char word, int index) {
-            this.word = word;
-            this.index = index;
-        }
-    }
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
-        String input = bf.readLine();
-        // 합들을 저장할 배열
-        int[] score = new int[input.length()];
-        Stack<Node> stack = new Stack<>();
-
-        for(int i=0;i<input.length();i++) {
-            // 스택이 비어있으면 해당 문자열을 넣고 다음으로 이동처리
-            if (stack.isEmpty()) {
-                stack.push(new Node(input.charAt(i), i));
-                continue;
-            }
-
-            Node node = stack.peek();
-            char currentWord = input.charAt(i);
-            // 이전 단어와 현재 단어가 매칭이 되는 경우
-            if ((node.word == '(' && currentWord == ')') || (node.word == '[' && currentWord == ']')) {
-                // 현재 단어와 매칭된 단어가 직전의 단어인 경우
-                if (node.index + 1 == i) {
-                    // '(' 인 경우는 score[앞괄호 인덱스] 에 2를 넣는다.
-                    // '[' 인 경우는 score[앞괄호 인덱스] 에 3을 넣는다.
-                    score[node.index] = node.word == '(' ? 2 : 3;
-                    // score[뒤괄호 인덱스]는 0으로 초기화한다.
-                    score[node.index+1] = 0;
-                }
-                // 현재 단어와 매칭된 단어가 직전의 단어가 아닌 경우 [중간에 매칭된 괄호들이 존재하는 경우]
-                else {
-                    int sum = 0;
-                    // 앞괄호 인덱스 +1 부터 뒷괄호 인덱스 -1 까지의 합을 더한다.
-                    for(int j=node.index+1;j<i;j++) sum += score[j];
-                    // score[앞괄호 인덱스] = (중간에 매칭된 괄호들의 합) * (가중치['(' => 2 , '[' => 3])
-                    score[node.index] = sum * (node.word == '(' ? 2 : 3);
-                    // 앞괄호 인덱스 +1 부터 뒷괄호 인덱스 까지 0으로 초기화한다.
-                    for(int j=node.index+1;j<=i;j++) score[j] = 0;
-                }
-                stack.pop();
-            }
-            // 매칭이 안된다면 스택에 넣는다.
-            else stack.push(new Node(currentWord, i));
-
-        }
-        System.out.println(!stack.isEmpty() ? 0 : Arrays.stream(score).sum());
-    }
-}
Index: minjae/week7/BOJ_18809_Gaaaaaaaaaarden.java
===================================================================
diff --git a/minjae/week7/BOJ_18809_Gaaaaaaaaaarden.java b/minjae/week7/BOJ_18809_Gaaaaaaaaaarden.java
deleted file mode 100644
--- a/minjae/week7/BOJ_18809_Gaaaaaaaaaarden.java	
+++ /dev/null	
@@ -1,120 +0,0 @@
-package week7;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-public class BOJ_18809_Gaaaaaaaaaarden {
-    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-    static StringTokenizer st;
-    static int N , M , G , R , Map[][] , result;
-    static List<int[]> ground;
-
-    static int delta[][] = {{0,1},{0,-1},{1,0},{-1,0}};
-
-    public static void main(String[] args) throws IOException {
-        st = new StringTokenizer(br.readLine());
-        N = Integer.parseInt(st.nextToken());
-        M = Integer.parseInt(st.nextToken());
-        G = Integer.parseInt(st.nextToken());
-        R = Integer.parseInt(st.nextToken());
-
-        Map = new int[N][M];
-        ground = new ArrayList<>();
-
-        for(int i = 0 ; i < N ;i++){
-            st = new StringTokenizer(br.readLine());
-            for (int j = 0; j < M; j++) {
-                Map[i][j] = Integer.parseInt(st.nextToken());
-                if(Map[i][j] == 2){
-                    ground.add(new int[] {i , j});
-                }
-            }
-        }
-        result = 0;
-
-        find(0, G, R ,ground.size()- G - R , new int[ground.size()]);
-        System.out.println(result);
-
-
-    }
-    static public void find(int cnt ,int green , int red , int blank , int []GR){
-
-        if(cnt == ground.size() ){
-            bfs(GR);
-        }
-
-        if(green != 0){
-            GR[cnt] = 1;
-            find(cnt + 1, green -1, red, blank, GR);
-        }
-        if(red != 0){
-            GR[cnt] = 2;
-            find(cnt + 1, green, red-1, blank, GR);
-        }
-        if(blank != 0){
-            GR[cnt] = 0;
-            find(cnt + 1, green, red, blank-1, GR);
-        }
-
-    }
-
-
-    static public void bfs(int[] GB){
-        int num = 0;
-        Queue<int[]> queue = new LinkedList<>();
-        int [][][]visitedGR = new int[N][M][3]; // 1 : G , 2 : R
-
-        for(int i = 0 ; i < N ;i++){
-            for (int j = 0; j < M; j++) {
-                visitedGR[i][j][1] = Integer.MAX_VALUE;
-                visitedGR[i][j][2] = Integer.MAX_VALUE;
-            }
-        }
-
-        for(int i = 0 ; i < ground.size(); i++){
-            if(GB[i] != 0){
-                int [] now = ground.get(i);
-                queue.add(new int[] {now[0], now[1] , GB[i], 1});
-                visitedGR[now[0]][now[1]][GB[i]] = 1;
-            }
-        }
-
-        while (!queue.isEmpty()) {
-            int[] now = queue.poll();
-
-            if (visitedGR[now[0]][now[1]][now[2]] == -1) continue;
-
-            for (int i = 0; i < 4; i++) {
-                int x = now[0] + delta[i][0];
-                int y = now[1] + delta[i][1];
-
-                int GR = now[2] ==1 ? 2 : 1;
-
-
-                if (x >= N || x < 0 || y >= M || y < 0 ) continue;
-                if(visitedGR[x][y][GR] < now[3]+1 || visitedGR[x][y][now[2]] <= now[3]+1 || Map[x][y] == 0) continue;
-
-                if(visitedGR[x][y][GR] == now[3]+1){
-                    visitedGR[x][y][GR] = -1;
-                    visitedGR[x][y][now[2]] = -1;
-                }else{
-                    visitedGR[x][y][now[2]] = now[3]+1;
-                    queue.add(new int[]{x, y, now[2], now[3]+1});
-                }
-
-            }
-        }
-
-
-        for(int i = 0 ; i < N ;i++){
-            for(int j = 0 ; j < M ;j++){
-                if(visitedGR[i][j][1] == -1) num++;
-            }
-        }
-        result = Math.max(result, num);
-
-
-    }
-}
\ No newline at end of file
Index: minjae/week6/BOJ_2812_크게만들기.java
===================================================================
diff --git a/minjae/week6/BOJ_2812_크게만들기.java b/minjae/week6/BOJ_2812_크게만들기.java
deleted file mode 100644
--- a/minjae/week6/BOJ_2812_크게만들기.java	
+++ /dev/null	
@@ -1,26 +0,0 @@
-package week6;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.Stack;
-import java.util.StringTokenizer;
-
-public class BOJ_2812_크게만들기 {
-    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-    static StringTokenizer st;
-
-    static int N , Min, Max, M , K, X , P;
-    static int Map[][];
-    static boolean checked[][][];
-
-    static int delta[][] = {{0,1},{0,-1},{1,0},{-1,0},{0,0}};
-    public static void main(String[] args) throws NumberFormatException, IOException {
-        // TODO Auto-generated method stub
-        // (()[[]])([])
-        // (, () ,[ , []]) , ( , [])
-        // 2 * ( 2 + 3 * 3 ) + 2 * 3
-
-
-    }
-}
\ No newline at end of file
Index: lsh9672/src/week06/BOJ1937_욕심쟁이판다.java
===================================================================
diff --git a/lsh9672/src/week06/BOJ1937_욕심쟁이판다.java b/lsh9672/src/week06/BOJ1937_욕심쟁이판다.java
deleted file mode 100644
--- a/lsh9672/src/week06/BOJ1937_욕심쟁이판다.java	
+++ /dev/null	
@@ -1,116 +0,0 @@
-package week06;
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.util.StringTokenizer;
-
-/**
- * 아이디어
- * dfs + dp를 이용해야 한다.
- * 500*500의 매우 큰 크기이므로, 매번 탐색할때 마다 최대 이동칸수를 구할 수 없다.
- * 한번 지나간 곳은 미리저장을 해둔다.
- * 예를 들어 (1,1)을 거쳐서 탐색했을때 나올수 있는 최대칸수가 10이라면, 이를 저장해두고 이후에는 (1,1)칸에 도달하면 더 탐색할 필요 없이 10을 반환해주면 된다.
- * 중요한 점은 방문처리는 할 필요가 없다.
- * 현재노드 값 보다 더 큰 값으로만 이동이 가능하다.
- * BOJ1520 문제와 비슷하다(이 문제는 다음노드가 더 작을떄.)
- */
-
-public class BOJ1937_욕심쟁이판다 {
-
-    //4방 탐색할때 이동좌표로 사용할 배열
-    private static final int[] dx = {-1, 1, 0, 0};
-    private static final int[] dy = {0, 0, -1, 1};
-
-    //탐색시 사용할 노드 객체
-    private static class Node{
-        int x, y;
-
-        public Node(int x, int y){
-            this.x = x;
-            this.y = y;
-        }
-
-        public int getX() {
-            return x;
-        }
-
-        public int getY() {
-            return y;
-        }
-    }
-
-    //격자형 그래프 크기 저장 변수.
-    private static int N;
-    //최대 이동 가능한 칸 개수
-    private static int maxCount;
-
-    //격자형 그래프
-    private static int[][] maps;
-
-    //이전에 탐색한 곳이면 저장해서 다음 탐색시에 다시 탐색하지 않도록 누적하는 배열.
-    private static int[][] dp;
-
-    //배열을 벗어나는지 체크
-    private static boolean check(int nextX, int nextY){
-        return nextX >= 0 && nextX < N &&
-                nextY >= 0 && nextY < N;
-    }
-
-    //재귀돌면서 탐색하기
-    private static int dfs(Node currentNode){
-
-        //dp 배열값이 있으면 이미 탐색이 끝난 곳이므로 반환.
-        if(dp[currentNode.x][currentNode.y] > 0){
-            return dp[currentNode.x][currentNode.y] + 1;
-        }
-
-        //4방향으로 탐색
-        for(int i = 0; i < 4; i++) {
-
-            int nextX = currentNode.x + dx[i];
-            int nextY = currentNode.y + dy[i];
-
-            //다음노드가 현재 노드보다 크다면 이동가능.
-            if(check(nextX,nextY) && (maps[currentNode.x][currentNode.y] < maps[nextX][nextY])){
-
-                dp[currentNode.x][currentNode.y] = Math.max(dp[currentNode.x][currentNode.y],dfs(new Node(nextX,nextY)));
-            }
-        }
-
-        //4방향을 전부 탐색했는데 갈 곳이 없으면 1리턴
-        return dp[currentNode.x][currentNode.y] + 1;
-
-    }
-
-    public static void main(String[] args) throws Exception{
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st;
-
-        N = Integer.parseInt(br.readLine());
-        maps = new int[N][N];
-        dp = new int[N][N];
-
-        maxCount = Integer.MIN_VALUE;
-
-        for(int i = 0; i < N; i++){
-            st = new StringTokenizer(br.readLine());
-
-            for(int j = 0; j < N; j++){
-                maps[i][j] = Integer.parseInt(st.nextToken());
-            }
-        }
-
-        //반복문 돌면서 각 칸을 시작점으로 두고 재귀 호출
-        for(int i = 0; i < N; i++){
-            for(int j = 0; j < N; j++){
-
-                //해당 칸에 저장된 값이 0이 아니고, 이전에 구한 최대값 보다 작다면 탐색할 필요 없음
-                if(dp[i][j] != 0 && dp[i][j] <= maxCount) continue;
-
-                maxCount = Math.max(maxCount,dfs(new Node(i,j)));
-            }
-        }
-
-        System.out.println(maxCount);
-    }
-}
Index: lsh9672/src/week07/BOJ18809_Gaaaaaaaaaarden.java
===================================================================
diff --git a/lsh9672/src/week07/BOJ18809_Gaaaaaaaaaarden.java b/lsh9672/src/week07/BOJ18809_Gaaaaaaaaaarden.java
deleted file mode 100644
--- a/lsh9672/src/week07/BOJ18809_Gaaaaaaaaaarden.java	
+++ /dev/null	
@@ -1,233 +0,0 @@
-package week07;
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.sql.Array;
-import java.util.*;
-
-/**
- * 아이디어
- * 조합 + 그래프 탐색
- * 배양액을 뿌릴 땅을 조합으로 선정, 모든 배양액을 다 뿌렸으면, bfs로 배양액을 퍼뜨린다
- * 배양액을 뿌릴 때는 땅을 하나 뽑고 해당 땅에 빨간색, 초록색, 안뿌리기 세개중 하나를 선택해서 재귀 호출을 하도록 한다.
- *
- */
-
-public class BOJ18809_Gaaaaaaaaaarden {
-
-    //4방향 탐색을 위한 배열.
-    private final static int[] dx = {-1, 1, 0, 0};
-    private final static int[] dy = {0, 0, -1, 1};
-
-    //위치좌표를 가지고 있을 객체.
-    private static class Location{
-        private int x, y;
-
-        public Location(int x, int y){
-            this.x = x;
-            this.y = y;
-        }
-
-        public int getX() {
-            return x;
-        }
-
-        public int getY() {
-            return y;
-        }
-    }
-
-    //bfs탐색에 사용할 노드객체
-    private static class Node{
-        private int x,y,time;
-        private char color;
-
-        public Node(int x, int y, int time, char color){
-            this.x = x;
-            this.y = y;
-            this.time = time;
-            this.color = color;
-        }
-
-        public int getX() {
-            return x;
-        }
-
-        public int getY() {
-            return y;
-        }
-
-        public int getTime() {
-            return time;
-        }
-
-        public char getColor() {
-            return color;
-        }
-
-        public Node createNewNode(){
-            return new Node(this.x, this.y, this.time, this.color);
-        }
-    }
-
-    //행
-    private static int N;
-    //열
-    private static int M;
-
-    //초록색 배양액 수
-    private static int G;
-    //빨간색 배양액 수.
-    private static int R;
-    //꽃의 최대개수 저장.
-    private static int maxFlower;
-    //배양액을 뿌릴 수 있는 위치를 나타낸 리스트
-    private static List<Location> growLocationList;
-    //bfs 시작 노드 큐
-    private static List<Node> growSetList;
-
-    //정원을 나타내는 배열
-    private static int[][] garden;
-
-
-    //bfs에서 이동 가능한 위치인지 체크하는 메서드
-    private static boolean check(int nextX, int nextY){
-
-        return nextX >= 0 && nextX < N &&
-                nextY >= 0 && nextY < M &&
-                garden[nextX][nextY] != 0;
-    }
-
-    //색 토글
-    private static char toggleColor(char color){
-        return color == 'G' ? 'R' : 'G';
-
-    }
-
-    //bfs를 돌리고 꽃의 수를 반환하는 메서드.
-    private static int bfs(){
-
-        int flowerCount = 0;
-
-        Map<Character, int[][]> visitedMap = new HashMap<>();
-
-        visitedMap.put('G', new int[N][M]);
-        visitedMap.put('R', new int[N][M]);
-
-        Queue<Node> needVisited = new ArrayDeque<>();
-
-        //선별한 노드들을 방문 처리 큐에 넣기. - 넣을떄는 새로운 객체로 복사해서 넣어야됨.
-        for(Node node : growSetList){
-
-            visitedMap.get(node.color)[node.getX()][node.getY()] = node.getTime();
-
-            needVisited.add(node.createNewNode());
-        }
-
-        while(!needVisited.isEmpty()){
-
-            Node currentNode = needVisited.poll();
-
-            //해당위치가 꽃이 되었으면 이동 불가.
-            if(visitedMap.get(currentNode.color)[currentNode.getX()][currentNode.getY()] == -1) continue;
-
-            for(int i = 0; i < 4; i++){
-                int nextX = currentNode.getX() + dx[i];
-                int nextY = currentNode.getY() + dy[i];
-
-                //방문체크, 이동 가능하고 호수가 아니고, 이동하지 않은 곳이며 꽃이 아니라면,
-                if(check(nextX,nextY) && visitedMap.get(currentNode.getColor())[nextX][nextY] == 0){
-
-                    //다른 색 배양액이 같은 시간이라면 꽃으로 변함.
-                    if(visitedMap.get(toggleColor(currentNode.getColor()))[nextX][nextY] == currentNode.getTime() + 1){
-
-                        //꽃으로 변환시킬떄는 빨간배열, 초록배열 모두체크해야됨.
-                        visitedMap.get('G')[nextX][nextY] = -1;
-                        visitedMap.get('R')[nextX][nextY] = -1;
-
-                        flowerCount++;
-                        continue;
-                    }
-                    //다른 색 배양액이 같은 시간이 아니고,
-                    needVisited.add(new Node(nextX, nextY, currentNode.getTime() + 1, currentNode.getColor()));
-                    visitedMap.get(currentNode.getColor())[nextX][nextY] = currentNode.getTime() + 1;
-
-                }
-            }
-        }
-
-
-        return flowerCount;
-    }
-
-    //재귀로 배양액을 배치할 메서드
-    private static void recursive(int index, int greenCount, int redCount){
-
-        //greenCount와 redCount둘 중 하나라도 최대 도달 개수를 넘어서면 종료.
-        if(greenCount > G || redCount > R) return;
-
-        //greenCount와 redCount가 최대 이면 bfs 돌림
-        if(greenCount == G && redCount == R){
-            maxFlower = Math.max(maxFlower, bfs());
-            return;
-        }
-
-        //greenCount와 redCount가 최대가 아닌데, index가 growLocationList크기이상이면 종료
-        if(index >= growLocationList.size()) return;
-
-        //놓을 곳 하나 뽑기
-        Location location = growLocationList.get(index);
-
-        //초록색을 놓는 경우
-        growSetList.add(new Node(location.getX(), location.getY(), 1, 'G'));//해당 위치의 값 넣기.
-
-        recursive(index + 1, greenCount + 1, redCount);//재귀호출
-
-        growSetList.remove(growSetList.size() - 1);//다음 탐색을 위한 원복
-
-        //빨간색을 놓는 경우
-        growSetList.add(new Node(location.getX(), location.getY(), 1, 'R'));//해당 위치의 값 넣기.
-
-        recursive(index + 1, greenCount, redCount + 1); //재귀 호출
-
-        growSetList.remove(growSetList.size() - 1);//다음 탐색을 위한 원복
-
-
-        //놓지 않는 경우.
-        recursive(index + 1, greenCount, redCount);
-
-    }
-
-
-    public static void main(String[] args) throws Exception{
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(br.readLine());
-
-        N = Integer.parseInt(st.nextToken());
-        M = Integer.parseInt(st.nextToken());
-        G = Integer.parseInt(st.nextToken());
-        R = Integer.parseInt(st.nextToken());
-
-        garden = new int[N][M];
-        maxFlower = Integer.MIN_VALUE;
-        growLocationList = new ArrayList<>();
-        growSetList = new ArrayList<>();
-
-        for(int i = 0; i < N; i++){
-            st = new StringTokenizer(br.readLine());
-
-            for(int j = 0; j < M; j++){
-
-                int value = Integer.parseInt(st.nextToken());
-                garden[i][j] = value;
-
-                //배양액을 뿌릴수 있는 땅 저장
-                if(value == 2) growLocationList.add(new Location(i,j));
-            }
-        }
-
-        recursive(0, 0, 0);
-        System.out.println(maxFlower);
-
-    }
-}
Index: minjae/week5/BOJ_16987_계란으로계란치기.java
===================================================================
diff --git a/minjae/week5/BOJ_16987_계란으로계란치기.java b/minjae/week5/BOJ_16987_계란으로계란치기.java
deleted file mode 100644
--- a/minjae/week5/BOJ_16987_계란으로계란치기.java	
+++ /dev/null	
@@ -1,83 +0,0 @@
-package week5;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.Arrays;
-import java.util.Stack;
-import java.util.StringTokenizer;
-import java.util.stream.Stream;
-
-public class BOJ_16987_계란으로계란치기 {
-    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-    static StringTokenizer st;
-
-    static int N , Min, Max, M , K, X , P;
-    static int Map[][];
-    static boolean checked[];
-
-    static int delta[][] = {{0,1},{0,-1},{1,0},{-1,0},{0,0}};
-    public static void main(String[] args) throws NumberFormatException, IOException {
-        // TODO Auto-generated method stub
-        N = Integer.parseInt(br.readLine());
-
-        Map = new int[N][2];
-        checked = new boolean[N];
-        Max = Integer.MIN_VALUE;
-        for (int i = 0; i < N ; i++) {
-            st = new StringTokenizer(br.readLine());
-            Map[i][0] = Integer.parseInt(st.nextToken());
-            Map[i][1] = Integer.parseInt(st.nextToken());
-        }
-
-
-
-        egg(0);
-        System.out.println(Max);
-
-
-    }
-
-    static public void egg(int cnt){
-        if(cnt == N){ // 끝
-            int result = 0;
-            for (int i = 0 ; i < N ;i++){
-                if(checked[i]){
-                    result++;
-                }
-            }
-            Max = Math.max(Max, result);
-            return;
-        }
-        if(!checked[cnt]){ // 손에 든 계란이 안 깨졌을경우
-            boolean flag = false;
-            for(int i = 0 ; i < N ;i++){
-                if(i != cnt && !checked[i]){
-                    flag = true;
-                    int handEgg = Map[cnt][0];
-                    int groundEgg = Map[i][0];
-
-                    Map[cnt][0] -= Map[i][1];
-                    Map[i][0] -= Map[cnt][1];
-                    checked[cnt] = Map[cnt][0] <= 0;
-                    checked[i] = Map[i][0] <= 0;
-
-                    egg(cnt + 1);
-
-                    Map[cnt][0] = handEgg;
-                    Map[i][0] = groundEgg;
-                    checked[cnt] = false;
-                    checked[i] = false;
-                }
-            }
-            if (!flag){  // 깰 계란이 없을때
-                egg(cnt + 1);
-            }
-        }else{ // 손에 든게 꺠졌을 경우
-            egg(cnt + 1);
-        }
-
-
-    }
-
-}
\ No newline at end of file
Index: lsh9672/src/week06/BOJ2138_전구와_스위치.java
===================================================================
diff --git a/lsh9672/src/week06/BOJ2138_전구와_스위치.java b/lsh9672/src/week06/BOJ2138_전구와_스위치.java
deleted file mode 100644
--- a/lsh9672/src/week06/BOJ2138_전구와_스위치.java	
+++ /dev/null	
@@ -1,90 +0,0 @@
-package week06;
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-
-/**
- * 그리디문제.
- * 여러 글에서 힌트를 얻어서 해결했다
- * 첫번째 전구는 +1번째에 영향을 주지 않는다.
- * 따라서 첫번째 전구를 킬때와 안킬때 두가지 경우로 보면 된다.
- * 각 상태를 볼때는 i번째 전구를 켰을때 i-1번째 값이 변화하게 되는데, 이 값이 답과 맞는지 보면 된다.
- * i가 증가하는 방향으로 보기때문에 i+1이 변화하는 것은 다음 반복에서 처리하도록 한다.
- */
-
-public class BOJ2138_전구와_스위치 {
-
-    //전구 수
-    private static int N;
-
-    //초기 전구 상태
-    private static String initBulb;
-
-    //만들고자 하는 전구 상태.
-    private static String finishedBulb;
-
-    //최종적으로 구할 변횐 회수
-    private static int minCount;
-
-    //토글 시키는 메서드
-    private static char toggle(char chr){
-
-        return chr == '0' ? '1' : '0';
-    }
-
-    //반복문 돌면서 전구 상태를 변화시켜감.
-    private static void changeStatus(boolean firstCheck){
-
-        char[] bulbArray = initBulb.toCharArray();
-
-        int count = 0;
-
-        //첫번째 값을 킴
-        if(firstCheck){
-            bulbArray[0] = toggle(bulbArray[0]);
-            bulbArray[1] = toggle(bulbArray[1]);
-            count++;
-        }
-
-        for(int i = 1; i < N; i++){
-
-            //i-1번째 값이 목표 문자열의 i - 1번째 값과 같으면 패스
-            if(bulbArray[i - 1] == finishedBulb.charAt(i - 1)) continue;
-
-            bulbArray[i - 1] = toggle(bulbArray[i - 1]);
-            bulbArray[i] = toggle(bulbArray[i]);
-            if(i < N - 1){
-                bulbArray[i + 1] = toggle(bulbArray[i + 1]);
-            }
-
-            count++;
-
-        }
-
-        if(finishedBulb.charAt(N - 1) == bulbArray[N - 1]){
-            minCount = Math.min(minCount, count);
-        }
-
-    }
-
-    public static void main(String[] args) throws Exception{
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-
-        N = Integer.parseInt(br.readLine());
-        initBulb = br.readLine();
-        finishedBulb = br.readLine();
-        minCount = Integer.MAX_VALUE;
-
-        changeStatus(false);
-        changeStatus(true);
-
-
-        if(minCount == Integer.MAX_VALUE){
-            System.out.println(-1);
-        }
-        else{
-            System.out.println(minCount);
-        }
-
-    }
-}
Index: minjae/week3/BOJ_1306_달려라홍준.java
===================================================================
diff --git a/minjae/week3/BOJ_1306_달려라홍준.java b/minjae/week3/BOJ_1306_달려라홍준.java
deleted file mode 100644
--- a/minjae/week3/BOJ_1306_달려라홍준.java	
+++ /dev/null	
@@ -1,114 +0,0 @@
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.PipedReader;
-import java.util.*;
-
-public class BOJ_1306_달려라홍준 {
-	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-	static StringTokenizer st;
-
-	static int N , Min, Max, M , K, X , P;
-
-	static int delta[][] = {{0,1},{0,-1},{1,0},{-1,0},{0,0}};
-
-	static int Map[][];
-	static boolean checked[];
-
-	static class SegmentTree{
-		int[] tree;
-		int treeSize;
-
-		SegmentTree(int arrSize){
-			//트리 높이 구하기
-			int h = (int)Math.ceil(Math.log(arrSize)/ Math.log(2)) + 1;
-			//높이를 통해 배열 사이즈 구하기
-			this.treeSize = (int)Math.pow(2, h);
-			// 배열 생성
-			tree = new int[treeSize];
-		}
-
-		/*
-		 *  arr = 원소 배열
-		 *  node = 현재노드
-		 *  start = 현재 구간 배열 시작
-		 *  end = 현재 구간 배열 끝
-		 */
-		int init(int[] arr , int node, int start, int end){
-			// 시작과 끝이 같다 = leaf노드
-			// 원소 배열 값 그대로 삽입
-			if(start == end){
-//                System.out.println(node + " : " + arr[start]);
-				return tree[node] = arr[start];
-			}else{
-				//leaf노드가 아닐경우 자식노드 합 삽입
-				return tree[node] = Math.max(init(arr, node*2 , start ,(start + end)/ 2)
-						,init(arr, node*2 + 1, (start+ end)/2 + 1 , end));
-			}
-		}
-
-		/*
-		 *  arr = 원소 배열
-		 *  node = 현재노드
-		 *  start = 현재 구간 배열 시작
-		 *  end = 현재 구간 배열 끝
-		 *  left = 원하는 누적합의 시작
-		 *  right = 원하는 누적합의 끝
-		 */
-		long sum(int node , int start , int end , int left , int right){
-			if(end < left || right < start){
-				return Integer.MIN_VALUE;
-			}else if (left <= start && end <= right){
-				return tree[node];
-			}else{
-				return Math.max(sum(node*2 , start , (start+ end)/ 2, left, right)
-						,sum(node*2+1 , (start+end)/2 +1 , end, left, right));
-			}
-		}
-
-		int maxNum(int node , int start , int end , int left , int right){
-			//리프 노드일 경우 해당 값을 반환
-			if(end == start){
-//                System.out.println(node + " " + start + " " + end + " : " + tree[node]);
-				return tree[node];
-			}else if(end < left || right < start){
-				//범위를 벗어나버릴 경우
-				return Integer.MIN_VALUE;
-			}else{
-				return Math.max(maxNum(node*2 , start , (start+ end)/ 2, left, right)
-						,maxNum(node*2+1 , (start+end)/2 +1 , end, left, right));
-			}
-		}
-
-
-	}
-
-	public static void main(String[] args) throws IOException {
-		st = new StringTokenizer(br.readLine());
-		N = Integer.parseInt(st.nextToken());
-		M = Integer.parseInt(st.nextToken());
-
-		st = new StringTokenizer(br.readLine());
-
-
-		int arr[] = new int[N+1];
-
-		for(int i = 0 ; i < N ;i++){
-			arr[i+1] = Integer.parseInt(st.nextToken());
-		}
-		SegmentTree seg = new SegmentTree(N);
-		seg.init(arr, 1 , 1 , N);
-		StringBuilder sb = new StringBuilder();
-//        Arrays.stream(seg.tree).forEach(System.out::println);
-		for(int i = M ;  i <= N - M + 1 ; i++){
-//            System.out.println((i - M + 1) + " " + (i + M -1));
-			sb.append(seg.sum(1,1,N,i - M + 1,i + M -1) + " ");
-		}
-
-		System.out.println(sb);
-
-
-
-
-	}
-}
\ No newline at end of file
Index: lsh9672/src/week06/BOJ2504_괄호의_값.java
===================================================================
diff --git a/lsh9672/src/week06/BOJ2504_괄호의_값.java b/lsh9672/src/week06/BOJ2504_괄호의_값.java
deleted file mode 100644
--- a/lsh9672/src/week06/BOJ2504_괄호의_값.java	
+++ /dev/null	
@@ -1,98 +0,0 @@
-package week06;
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Stack;
-
-/**
- * 아이디어
- * 스택을 이용하는 문제
- * 괄호를 하나씩 스택에 넣고, 닫는 괄호면 스택안의 값과 비교해서 확인한다.
- * 숫자라면 연산후에 다시넣는다.
- * 완벽한 괄호라면 계산하고 나온 수를 다시 넣어서 다음 괄호 또는 최종연산에 사용한다.
- *
- * (수정)
- * 여는 괄호면 괄호에 맞게 2 또는 3을 변수에 곱해준다.(해당 변수의 초기값은 1)
- * 닫는 괄호가 나오면 이전에 저장해둔 괄호랑 비교해서 올바른 괄호라면, 저장해둔 값을 최종 출력 변수에 더해준다,
- * 이 때 중요한 것은, 여는 괄호가 나올때 마다 곱해줬으니, 닫는 괄호가 나와서 종료를 했으면 그 수만 큼 나눠줘야 다음 괄호가 해당 연산을 할 수 있다.
- */
-
-public class BOJ2504_괄호의_값 {
-
-    public static void main(String[] args) throws Exception{
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-
-        String bracketStr = br.readLine();
-
-        //괄호처리할 스택 선언
-        Stack<Character> bracketStack = new Stack<>();
-
-        //최종적인 값을 반환할 값
-        int resultValue = 0;
-        //여는 괄호가 나올때 마다 누적해둘 변수
-        int tempValue = 1;
-
-
-        //반복문 돌면서 넣기
-        loop:
-        for(int i = 0; i < bracketStr.length(); i++){
-
-            //문자열 하나 빼기.
-            char temp = bracketStr.charAt(i);
-
-            switch(temp){
-                // 여는 소괄호라면
-                case '(':
-                    //2를 곱해서 누적시켜두고 스택에 넣음
-                    tempValue *= 2;
-                    bracketStack.push(temp);
-                    break;
-                //여는 대괄호 라면
-                case '[':
-                    //3를 곱해서 누적시켜두고 스택에 넣음
-                    tempValue *= 3;
-                    bracketStack.push(temp);
-                    break;
-
-                //닫는 소괄호라면
-                case ')':
-                    //스택의 마지막 값을 확인해야 함 - 맞는 괄호가 아니라면 0을 출력하도록 함.
-                    if(bracketStack.isEmpty() || bracketStack.peek() != '('){
-                        resultValue = 0;
-                        break loop;
-                    }
-
-                    //맞는 괄호라면.
-
-                    //최종 출력변수에 누적한 값 저장하고, 다음 연산을 위해 나누기2를 함.
-                    //바로 이전값이 여는 괄호,일때만 계산.
-                    if(bracketStr.charAt(i - 1) == '(') resultValue += tempValue;
-                    tempValue /= 2;
-                    bracketStack.pop();
-
-                    break;
-
-                //닫는 대괄호라면
-                case ']':
-                    if(bracketStack.isEmpty() || bracketStack.peek() != '['){
-                        resultValue = 0;
-                        break loop;
-                    }
-
-                    //맞는 괄호라면.
-                    //최종 출력변수에 누적한 값 저장하고, 다음 연산을 위해 나누기3를 함.
-                    if(bracketStr.charAt(i - 1) == '[') resultValue += tempValue;
-                    tempValue /= 3;
-                    bracketStack.pop();
-
-                    break;
-            }
-        }
-
-        if(!bracketStack.isEmpty()) resultValue = 0;
-        System.out.println(resultValue);
-
-    }
-}
Index: minjae/week7/BOJ_2143_두배열의합_twoPoint.java
===================================================================
diff --git a/minjae/week7/BOJ_2143_두배열의합_twoPoint.java b/minjae/week7/BOJ_2143_두배열의합_twoPoint.java
deleted file mode 100644
--- a/minjae/week7/BOJ_2143_두배열의합_twoPoint.java	
+++ /dev/null	
@@ -1,94 +0,0 @@
-package week7;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.Arrays;
-import java.util.StringTokenizer;
-
-public class BOJ_2143_두배열의합_twoPoint {
-    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-    static StringTokenizer st;
-    static int T, N , M;
-    public static void main(String[] args) throws IOException {
-
-        T = Integer.parseInt(br.readLine());
-        N = Integer.parseInt(br.readLine());
-        int arrA[] = new int[N];
-        st = new StringTokenizer(br.readLine());
-
-        for (int i = 0; i < N; i++) {
-            arrA[i] = Integer.parseInt(st.nextToken());
-        }
-
-        M = Integer.parseInt(br.readLine());
-        int arrB[] = new int[M];
-        st = new StringTokenizer(br.readLine());
-
-        for (int i = 0; i < M; i++) {
-            arrB[i] = Integer.parseInt(st.nextToken());
-        }
-
-        int aSize = N*(N+1)/2;
-        long[] aSum = new long[aSize];
-        int idx=0;
-        for(int i=0; i<N; i++) {
-            int av=0;
-            for(int j=i; j<N; j++) {
-                av+=arrA[j];
-                aSum[idx++] = av;
-            }
-        }
-
-
-
-        int bSize = M*(M+1)/2;
-        long[] bSum = new long[bSize];
-        idx=0;
-        for(int i=0; i<M; i++) {
-            int bv=0;
-            for(int j=i; j<M; j++) {
-                bv+=arrB[j];
-                bSum[idx++] = bv;
-            }
-        }
-
-        Arrays.sort(aSum);
-        Arrays.sort(bSum);
-
-        int left = 0;
-        int right = bSize-1;
-        long cnt = 0;
-
-        while (left < aSize && right >= 0){
-
-            long sum = aSum[left] + bSum[right];
-
-            if(sum == T){
-                long a = aSum[left];
-                long b = bSum[right];
-
-                long aCnt =0;
-                long bCnt = 0;
-
-                while (left < aSize && aSum[left] == a){
-                    aCnt++;
-                    left++;
-                }
-                while (right >=0 && bSum[right] == b){
-                    bCnt++;
-                    right--;
-                }
-                cnt += aCnt * bCnt;
-            }else if(sum < T){
-                left++;
-            }else{
-                right--;
-            }
-
-        }
-        System.out.println(cnt);
-
-
-    }
-}
\ No newline at end of file
Index: chansik/src/week07/BOJ_18809_Gaaaaaaaarden.java
===================================================================
diff --git a/chansik/src/week07/BOJ_18809_Gaaaaaaaarden.java b/chansik/src/week07/BOJ_18809_Gaaaaaaaarden.java
deleted file mode 100644
--- a/chansik/src/week07/BOJ_18809_Gaaaaaaaarden.java	
+++ /dev/null	
@@ -1,134 +0,0 @@
-package chansik.src.week07;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-public class BOJ_18809_Gaaaaaaaarden {
-    static int[][] move = {{-1,0},{1,0},{0,1},{0,-1}};
-    static int ans;
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(bf.readLine());
-        int n = Integer.parseInt(st.nextToken());
-        int m = Integer.parseInt(st.nextToken());
-        int g = Integer.parseInt(st.nextToken());
-        int r = Integer.parseInt(st.nextToken());
-        ans = 0;
-        int[][] map = new int[n][m];
-        List<int[]> areaList = new ArrayList<>();
-        List<int[]> posList = new ArrayList<>();
-        for(int i=0;i<n;i++) {
-            st = new StringTokenizer(bf.readLine());
-            for(int j=0;j<m;j++) {
-                map[i][j] = Integer.parseInt(st.nextToken());
-                if(map[i][j] == 2) areaList.add(new int[]{i, j});
-                map[i][j] = map[i][j] == 0 ? -1 : 0;
-            }
-        }
-
-        /**
-         * 1. 빨간배양액과 초록배양액이 뿌려질 수 있는 좌표의 조합을 구한다.
-         * 2. 해당 좌표에 배양액을 뿌린다.
-         * 3. 확산한다.
-         *
-         *  확산 시 주의할점
-         *  이미 확산이 일어난곳은 확산을 할 수 없다.
-         *  꽃이 피워진 곳 또한 확산할 수 없다.
-         *  동시에 확산된다면 그 자리에는 꽃이 생긴다.
-         */
-
-        dfs(map, areaList, posList, 0, 0, 0, n, m, r, g);
-        System.out.println(ans);
-    }
-
-    public static int spread(int[][] map, List<int[]> posList, int n, int m) {
-        int flowerCnt = 0;
-        boolean[][] vis = new boolean[n][m];
-        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[3] - o2[3]);
-        List<int[]> passList = new ArrayList<>();
-        for (int[] info : posList) {
-            int r = info[0]; int c = info[1]; int flg = info[2];
-            pq.add(new int[]{r, c, flg, 0});
-            vis[r][c] = true;
-            map[r][c] = flg;
-        }
-
-        int curSpCnt = 0;
-        while(!pq.isEmpty()) {
-            int[] info = pq.poll();
-            int r = info[0]; int c = info[1]; int flg = info[2]; int spCnt = info[3];
-
-            if (spCnt != curSpCnt) {
-                curSpCnt = spCnt;
-                for (int[] passInfo : passList) {
-                    int pr = passInfo[0]; int pc = passInfo[1];
-                    vis[pr][pc] = true;
-                }
-                passList.clear();
-            }
-
-            if (map[r][c] == 3) continue;
-            for(int i=0;i<4;i++) {
-                int nr = r + move[i][0];
-                int nc = c + move[i][1];
-                if(isCheck(nr, nc, n, m) && map[nr][nc] != -1 && !vis[nr][nc]) {
-                    if (map[nr][nc] == 0) {
-                        map[nr][nc] += flg;
-                        pq.add(new int[]{nr, nc, flg, spCnt + 1});
-                        passList.add(new int[]{nr, nc});
-                    }
-                    else if((map[nr][nc] == 1 && flg == 2) || (map[nr][nc] == 2 && flg == 1)) {
-                        map[nr][nc] += flg;
-                        vis[nr][nc] = true;
-                    }
-                }
-            }
-
-        }
-
-        flowerCnt = findFlower(map);
-
-        return flowerCnt;
-    }
-
-    public static int findFlower(int[][] map) {
-        int count = 0;
-        for(int i=0;i<map.length;i++) count += Arrays.stream(map[i]).filter(x -> x == 3).count();
-        return count;
-    }
-
-    public static int[][] copy(int[][] map) {
-        int[][] copyMap = new int[map.length][map[0].length];
-        for(int i=0;i<map.length;i++)
-            for(int j=0;j<map[i].length;j++) copyMap[i][j] = map[i][j];
-        return copyMap;
-    }
-
-    public static boolean isCheck(int r, int c, int n, int m) {
-        return r>= 0 && r < n && c >= 0 && c < m;
-    }
-    public static void dfs(int[][] map, List<int[]> areaList, List<int[]> posList ,int index, int rCount, int gCount, int n, int m, int r, int g) {
-
-        if (rCount == r && gCount == g) {
-            ans = Math.max(ans, spread(copy(map), posList, n, m));
-            return;
-        }
-
-        if (index == areaList.size()) return;
-
-        if (rCount < r) {
-            List<int[]> rList = new ArrayList<>(posList);
-            rList.add(new int[]{areaList.get(index)[0], areaList.get(index)[1], 1});
-            dfs(map, areaList, rList, index+1, rCount + 1, gCount, n, m, r, g);
-        }
-        if (gCount< g) {
-            List<int[]> gList = new ArrayList<>(posList);
-            gList.add(new int[]{areaList.get(index)[0], areaList.get(index)[1], 2});
-            dfs(map, areaList, gList, index+1, rCount, gCount + 1, n, m, r, g);
-        }
-        dfs(map, areaList, posList, index+1, rCount, gCount, n, m, r, g);
-
-    }
-}
\ No newline at end of file
Index: lsh9672/src/week07/BOJ2143_두_배열의_합.java
===================================================================
diff --git a/lsh9672/src/week07/BOJ2143_두_배열의_합.java b/lsh9672/src/week07/BOJ2143_두_배열의_합.java
deleted file mode 100644
--- a/lsh9672/src/week07/BOJ2143_두_배열의_합.java	
+++ /dev/null	
@@ -1,137 +0,0 @@
-package week07;
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.StringTokenizer;
-
-/**
- * 아이디어
- * 연속된 배열의 합이므로 우선 누적합을 이용하는 방법을 생각했다.
- * 모든 경우를 다 해보는 수 밖에 없다.
- * 우선 각 배열의 누적합을 구한 후, 이 누적합 배열을 이용해서 나올 수 있는 모든 경우의 수를 리스트에 담는다.
- * 이렇게 만들어진 a,b 배열을 이용해서 조합을 해보고, T가 나오면 저장을 하는 식으로 한다.
- * 이때 단순 이중 반복문이 아닌 투 포인터를 이용해서 해결을 해준다.
- */
-public class BOJ2143_두_배열의_합 {
-
-    //누적값 구하는 메서드
-    private static void makeSum(int[] array){
-
-        for(int i = 1; i < array.length; i++){
-            array[i] += array[i - 1];
-        }
-    }
-
-    //구간 값 리스트에 넣는 메서드
-    private static void allValueSave(int[] array, List<Integer> list){
-
-        list.add(array[0]); //첫번째 값은 넣어두기.
-
-        for(int i = 1; i < array.length; i++){
-            list.add(array[i]);
-            for(int j = 0; j < i; j++){
-
-                list.add(array[i] - array[j]);
-            }
-        }
-    }
-
-    public static void main(String[] args) throws Exception{
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st;
-
-        //T저장 변수
-        int T = Integer.parseInt(br.readLine());
-
-        //n - a배열길이
-        int n = Integer.parseInt(br.readLine());
-        //a배열
-        int[] aArray = new int[n];
-        //a배열의 모든 구간 값을 저장할 리스트
-        List<Integer> aSumList = new ArrayList<>();
-        st = new StringTokenizer(br.readLine());
-
-        for(int i = 0; i < n; i++){
-            aArray[i] = Integer.parseInt(st.nextToken());
-        }
-
-        //m - b배열 길이
-        int m = Integer.parseInt(br.readLine());
-        //b배열
-        int[] bArray = new int[m];
-        st = new StringTokenizer(br.readLine());
-        //b배열의 모든 구간 값을 저장할 리스트.
-        List<Integer> bSumList = new ArrayList<>();
-
-        for(int i = 0; i < m; i++){
-            bArray[i] = Integer.parseInt(st.nextToken());
-        }
-
-        //누적합 구해두기.
-        makeSum(aArray);
-        makeSum(bArray);
-
-        //각 배열의 모든 구간 값을 리스트에 저장.
-        allValueSave(aArray, aSumList);
-        allValueSave(bArray, bSumList);
-
-        //투 포인터를 구하기 위해서 정렬
-        Collections.sort(aSumList);
-        Collections.sort(bSumList);
-
-        long result = 0; //나올 수 있는 경우의 수.
-
-        int left = 0; //a리스트의 처음 위치에서 시작.
-        int right = bSumList.size() - 1; //b리스트의 가장 끝쪽에서 시작
-
-        //두 값의 합이, T보다 크다면,right를 감소시켜서 값을 줄여봄
-        //두 값의 합이, T보다 작다면, left값을 증가시켜서 값을 키움
-        //두 값의 합이, T라면, 경우의 수를 증가시키고, 둘 중 하나의 값을 키우거나 줄여봄 - 중복값이 있을 수 있기 때문에 T가 아닐때 까지 값을 변경해봄.
-
-        //인덱스를 벗어나지 않을때까지 반복.
-        while(left < aSumList.size() && right >= 0){
-
-            //두 값의 합.
-            int sumValue = aSumList.get(left) + bSumList.get(right);
-
-            //클 때
-            if(sumValue > T){
-                right--;
-            }
-            //작을떄,
-            else if(sumValue < T){
-                left++;
-            }
-            //같을때 - 중복값이 있기 떄문에 a,b리스트 모두 상한선,하한선까지 탐색필요.
-            else{
-
-                //현재 인덱스 값 임시 저장.
-                int aTemp = aSumList.get(left);
-                int bTemp = bSumList.get(right);
-
-                //해당 하는 값의 개수를 누적해야됨 - 만들수 있는 수는, aTempCount * bTempCount이다.
-                long aTempCount = 0;
-                long bTempCount = 0;
-
-                //a리스트쪽 인덱스를 증가시키면서 기존의 값과 동일한지 확인.
-                while(left < aSumList.size() && aSumList.get(left) == aTemp){
-                    aTempCount++;
-                    left++;
-                }
-
-                //b리스트쪽 인덱스를 감소시키면서 기존의 값과 동일한지 확인.
-                while(right >= 0 && bSumList.get(right) == bTemp){
-                    bTempCount++;
-                    right--;
-                }
-
-
-                result += aTempCount * bTempCount;
-            }
-        }
-        System.out.println(result);
-    }
-}
Index: minjae/week5/BOJ_2812_크게만들기.java
===================================================================
diff --git a/minjae/week5/BOJ_2812_크게만들기.java b/minjae/week5/BOJ_2812_크게만들기.java
deleted file mode 100644
--- a/minjae/week5/BOJ_2812_크게만들기.java	
+++ /dev/null	
@@ -1,48 +0,0 @@
-package week5;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.Stack;
-import java.util.StringTokenizer;
-
-public class BOJ_2812_크게만들기 {
-    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-    static StringTokenizer st;
-
-    static int N , Min, Max, M , K, X , P;
-    static int Map[][];
-    static boolean checked[][][];
-
-    static int delta[][] = {{0,1},{0,-1},{1,0},{-1,0},{0,0}};
-    public static void main(String[] args) throws NumberFormatException, IOException {
-        // TODO Auto-generated method stub
-        st = new StringTokenizer(br.readLine());
-        N = Integer.parseInt(st.nextToken());
-        K = Integer.parseInt(st.nextToken());
-
-        String s = br.readLine();
-        Stack<Integer> stack = new Stack<>();
-        stack.push(s.charAt(0) -'0');
-
-        for (int i = 1; i < s.length(); i++) {
-            int now = s.charAt(i) - '0';
-            while (stack.size() != 0 && stack.peek() < now && K != 0){
-                stack.pop();
-                K--;
-            }
-            stack.push(now);
-        }
-
-
-        while (K != 0){
-            stack.pop();
-            K--;
-        }
-
-        for (int a : stack){
-            System.out.print(a);
-        }
-    }
-
-}
\ No newline at end of file
Index: minjae/test.java
===================================================================
diff --git a/minjae/test.java b/minjae/test.java
deleted file mode 100644
--- a/minjae/test.java	
+++ /dev/null	
@@ -1,66 +0,0 @@
-import java.util.Arrays;
-
-public class test {
-    public static void dijkstra(int[][] graph, int start) {
-        int V = graph.length;
-        int[] distance = new int[V];
-        boolean[] visited = new boolean[V];
-
-        Arrays.fill(distance, Integer.MAX_VALUE);
-        distance[start] = 0;
-
-        for (int i = 0; i < V - 1; i++) {
-            int minDistance = findMinDistance(distance, visited);
-            visited[minDistance] = true;
-
-            for (int j = 0; j < V; j++) {
-                if (!visited[j] && graph[minDistance][j] != 0 && distance[minDistance] != Integer.MAX_VALUE
-                        && distance[minDistance] + graph[minDistance][j] < distance[j]) {
-                    distance[j] = distance[minDistance] + graph[minDistance][j];
-                }
-            }
-        }
-
-        printShortestDistances(distance);
-    }
-
-    public static int findMinDistance(int[] distance, boolean[] visited) {
-        int V = distance.length;
-        int minDistance = Integer.MAX_VALUE;
-        int minIndex = -1;
-
-        for (int i = 0; i < V; i++) {
-            if (!visited[i] && distance[i] <= minDistance) {
-                minDistance = distance[i];
-                minIndex = i;
-            }
-        }
-
-        return minIndex;
-    }
-
-    public static void printShortestDistances(int[] distance) {
-        int V = distance.length;
-        System.out.println("Shortest distances from the starting node:");
-        for (int i = 0; i < V; i++) {
-            System.out.println("To node " + i + ": " + distance[i]);
-        }
-    }
-
-    public static void main(String[] args) {
-        int[][] graph = {
-                {0, 4, 0, 0, 0, 0, 0, 8, 0},
-                {4, 0, 8, 0, 0, 0, 0, 11, 0},
-                {0, 8, 0, 7, 0, 4, 0, 0, 2},
-                {0, 0, 7, 0, 9, 14, 0, 0, 0},
-                {0, 0, 0, 9, 0, 10, 0, 0, 0},
-                {0, 0, 4, 14, 10, 0, 2, 0, 0},
-                {0, 0, 0, 0, 0, 2, 0, 1, 6},
-                {8, 11, 0, 0, 0, 0, 1, 0, 7},
-                {0, 0, 2, 0, 0, 0, 6, 7, 0}
-        };
-
-        int startNode = 0;
-        dijkstra(graph, startNode);
-    }
-}
\ No newline at end of file
Index: chansik/src/week08/BOJ_17485_진우의달여행_Large.java
===================================================================
diff --git a/chansik/src/week08/BOJ_17485_진우의달여행_Large.java b/chansik/src/week08/BOJ_17485_진우의달여행_Large.java
deleted file mode 100644
--- a/chansik/src/week08/BOJ_17485_진우의달여행_Large.java	
+++ /dev/null	
@@ -1,53 +0,0 @@
-package chansik.src.week08;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.StringTokenizer;
-
-public class BOJ_17485_진우의달여행_Large {
-    static int[][] move = {{-1,-1},{-1,0},{-1,1}};
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(bf.readLine());
-        int n = Integer.parseInt(st.nextToken());
-        int m = Integer.parseInt(st.nextToken());
-        int[][] map = new int[n][m];
-        int[][][] dp = new int[3][n][m];
-        for(int i=0;i<n;i++) {
-            st = new StringTokenizer(bf.readLine());
-            for(int j=0;j<m;j++) {
-                map[i][j] = Integer.parseInt(st.nextToken());
-                for(int k=0;k<3;k++) dp[k][i][j] = Integer.MAX_VALUE;
-            }
-        }
-
-        for(int i=0;i<m;i++) {
-            for(int j=0;j<3;j++) dp[j][0][i] = map[0][i];
-        }
-
-        for(int i=1;i<n;i++) {
-            for(int j=0;j<m;j++) {
-                for(int k=0;k<3;k++) {
-                    int pr = i + move[k][0];
-                    int pc = j + move[k][1];
-                    if (isCheck(pr, pc, n, m)) {
-                        for(int dir=0;dir<3;dir++) {
-                            if (dir == k || dp[dir][pr][pc] == Integer.MAX_VALUE) continue;
-                            dp[k][i][j] = Math.min(dp[k][i][j], dp[dir][pr][pc] + map[i][j]);
-                        }
-                    }
-                }
-            }
-        }
-
-        int min = Integer.MAX_VALUE;
-        for(int i=0;i<m;i++)
-            for(int k=0;k<3;k++) min = Math.min(min, dp[k][n-1][i]);
-        System.out.print(min);
-    }
-
-    public static boolean isCheck(int r, int c, int n, int m) {
-        return r>=0 && r < n && c >=0 && c < m;
-    }
-}
\ No newline at end of file
Index: minjae/week2/BOJ_6987_레이저통신.java
===================================================================
diff --git a/minjae/week2/BOJ_6987_레이저통신.java b/minjae/week2/BOJ_6987_레이저통신.java
deleted file mode 100644
--- a/minjae/week2/BOJ_6987_레이저통신.java	
+++ /dev/null	
@@ -1,102 +0,0 @@
-package week2;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.Arrays;
-import java.util.LinkedList;
-import java.util.Queue;
-import java.util.StringTokenizer;
-
-public class BOJ_6987_레이저통신 {
-    static int N, M;
-    static int delta[][] = {{1,0},{0,1},{-1,0},{0,-1}};
-    static char Map[][];
-    public static void main(String[] args) throws IOException {
-
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(br.readLine());
-
-
-        M = Integer.parseInt(st.nextToken());
-        N = Integer.parseInt(st.nextToken());
-
-        Map = new char[N][M];
-
-        Queue<int[]> start = new LinkedList<>();
-
-        for (int i = 0; i < N; i++) {
-            String s = br.readLine();
-            for (int j = 0; j < M; j++) {
-                Map[i][j] = s.charAt(j);
-
-                if(Map[i][j] == 'C'){
-                    start.add(new int[] {i , j});
-                }
-            }
-        }
-
-        int [] first = start.poll();
-        int [] second = start.poll();
-
-        dfs(first[0] , first[1] , second[0] , second[1]);
-
-
-
-    }
-
-    public static void dfs(int startX , int startY , int endX, int endY){
-
-        int checked[][] = new int[N][M];
-
-        for(int i = 0 ; i < N ;i++){
-            Arrays.fill(checked[i] , 999999);
-        }
-
-        checked[startX][startY] = 0;
-
-        Queue<int[]> queue = new LinkedList<>();
-        for(int i = 0 ; i < 4 ; i++){
-            queue.add(new int[] {startX , startY , i, 0});
-        }
-
-
-        while (!queue.isEmpty()){
-            int []now = queue.poll();
-
-            if(now[0] == endX && now[1] == endY) continue;
-
-//
-//            for(int i = 0 ; i < N ;i++){
-//                for(int j = 0 ; j < M ;j++){
-//                    System.out.print(checked[i][j] + " " );
-//                }
-//                System.out.println();
-//            }
-//
-//            System.out.println("---");
-
-
-            int direct = now[2];
-            int x = now[0] + delta[direct][0];
-            int y = now[1] + delta[direct][1];
-
-            if(x < 0 || x >= N || y < 0 || y >= M || Map[x][y] == '*') continue;
-
-
-            if(checked[x][y] > now[3]){         // 아직 안간곳
-                checked[x][y] = now[3];
-                queue.add(new int[]{x,y,now[2] , now[3]});
-                queue.add(new int[]{x,y,(now[2]+1)%4 , now[3]+1});
-                queue.add(new int[]{x,y,(now[2]-1 < 0 ? 3 : now[2]-1) , now[3]+1});
-            } else if (checked[x][y] == now[3]) {
-                queue.add(new int[]{x,y,now[2] , now[3]});
-            }
-        }
-
-        System.out.println(checked[endX][endY]);
-
-
-
-    }
-}
\ No newline at end of file
Index: lsh9672/src/week08/BOJ16235_나무_재테크.java
===================================================================
diff --git a/lsh9672/src/week08/BOJ16235_나무_재테크.java b/lsh9672/src/week08/BOJ16235_나무_재테크.java
deleted file mode 100644
--- a/lsh9672/src/week08/BOJ16235_나무_재테크.java	
+++ /dev/null	
@@ -1,276 +0,0 @@
-package week08;
-
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.StringTokenizer;
-
-/**
- * 아이디어
- * 빡구현 문제로, 별도의 아이디어가 필요 없다. 시키는 대로 구현하면 된다.
- *
- * 각 계절마다 동작하는 메서드를 만들고, 한번의 반복마다 4가지 메서드를 동작시켜주면 된다.
- * K년까지 반복이 끝나면 맵을 돌면서 살아있는 나무의 수를 구하면 된다.
- * 가장 중요한 것은 빠르게 문제를 찾고 수정할 수 있도록 코드를 모듈처럼 잘 나눠야하고, 나무의 상태등은 반드시 객체를 이용해야 한다.
- *
- * 주의해야 할 점은, 각 칸에 나무가 여러개 심어져 있을 수도 있다.
- *
- * (수정)
- * 또한 봄과 여름을 따로 구했는데, 봄과정을 진행하면서 죽은 나무를 바로 모아뒀다가 나무를 다죽이면 마지막에 모아둔 값을 양분으로 업데이트 하는 식으로
- * 하나의 과정으로 줄이는 것이 좋을 것 같다.
- *
- * (수정2)
- * 나무가 각 땅에 여러개 존재하는데, 이를 리스트를 이용해서 관리하고 있다.
- * 이때 죽은 나무를 삭제하는 것이 아닌, 삭제 체크만해서 유지하고 있는데, 이 방법이 시간초과를 만드는 듯 하다.
- * 계속해서 정렬하고 있는데, 정렬할 필요가 없다.
- * 새로운 나무는 나이 1을 가지고 추가 되는데, 리스트로 관리한다면 왼쪽에 추가하는 식으로 해서 오름차순을 유지할 수 있다.
- * 오름차순이 깨질 가능성이 있는 부분은 양분을 먹고 나이가 증가되는 봄이다.
- * 하지만 잘생각해보면, 오름차순이면 i번째와 i+1번째는 같거나, i+1번째가 더 크다
- * i번째가 양분을 먹고 1증가 했다면, i+1번의 경우, 동일하게 1증가하거나, 죽거나 둘중 하나다.
- * 결국 양분을 먹더라도 i가 i+1의 나이를 역전하는 경우는 발생 할 수 없다.
- *
- */
-public class BOJ16235_나무_재테크 {
-
-    //8방향에 번식 - 상하좌우, 좌상,좌하, 우상,우하
-    private final static int[] dx = {-1, 1, 0, 0, -1, 1, -1, 1};
-    private final static int[] dy = {0, 0, -1, 1, -1, -1, 1, 1};
-
-    private static class Tree{
-        int age;
-
-        //이전 노드와 다음 노드값
-        Tree prev, next;
-
-        public Tree(int age){
-            this.age = age;
-            this.prev = null;
-            this.next = null;
-        }
-
-        public int getAge() {
-            return age;
-        }
-
-        //5의 배수면 번식가능
-        public boolean breedable(){
-            if(this.age % 5 == 0) return true;
-
-            return false;
-        }
-
-        //해당 양분보다 나이가 많으면 먹음
-        public boolean eatNutrient(int x, int y){
-
-            //해당 양분보다 나이가 작거나 같으면 나이를 1살 먹음
-            if(this.age <= maps[x][y]){
-                maps[x][y] -= this.age;
-                this.age++;
-                return true;
-            }
-
-            return false;
-        }
-
-        public void addTree(Tree tree){
-            //노드 연결
-            tree.next = this;
-            this.prev = tree;
-        }
-
-        public void deleteTree(){
-            this.next = null;
-        }
-
-    }
-
-    //땅 크기
-    private static int N;
-    //나무 개수
-    private static int M;
-    //몇년
-    private static int K;
-
-    //땅을 나타낼 배열.
-    private static int[][] maps;
-
-    //겨울에 각 칸마다 추가되는 양분의 양을 저장할 배열
-    private static int[][] nutrientMaps;
-
-    //나무 정보를 나타낼 배열. - 내부를 리스트로 하고, 정렬 하도록 한다.
-    private static Tree[][] treeInfo;
-
-    //가능한 칸인지 확인
-    private static boolean check(int nextX, int nextY){
-        return nextX >= 0 && nextX < N &&
-                nextY >= 0 && nextY < N;
-    }
-
-    //봄에 나무를 처리할 메서드
-    private static void springAndSummer(){
-
-        for(int i = 0; i < N; i++){
-            for(int j = 0; j < N; j++){
-
-                //나무 리스트를 뽑음
-                Tree tree = treeInfo[i][j];
-
-
-                //해당 노드가 null이 아니고, 먹을 수 있다면 먹음.
-                while(tree != null && tree.eatNutrient(i,j)){
-                    tree = tree.next;
-                }
-
-
-                Tree deleteTree = tree;
-
-                int totalNewNutrient = 0; //해당칸에 추가할 총 양분
-
-                //먹고 나이먹는 나무뒤로는 전부다 죽여야 됨.
-                while(tree != null){
-                    totalNewNutrient += tree.getAge() / 2;
-                    tree = tree.next;
-                }
-
-
-                maps[i][j] += totalNewNutrient;
-
-                //트리 삭제
-                if(deleteTree != null){
-                    if(deleteTree.prev != null) deleteTree.prev.deleteTree(); //앞의 노드가 있으면 삭제.
-                    else treeInfo[i][j] = null; //앞에 노드가 없으면 해당 배열에 헤드노드 삭제
-                }
-
-
-            }
-        }
-
-    }
-
-    //나무의 나이가 5의 배수면 번식
-    private static void breeding(int x, int y){
-
-        Tree tree = treeInfo[x][y];
-
-        while(tree != null){
-
-            if(tree.breedable()){
-                //번식가능하면 8방향에 번식.
-                for(int i = 0; i < 8; i++){
-                    int nextX = x + dx[i];
-                    int nextY = y + dy[i];
-
-                    if(check(nextX, nextY)){
-
-                        Tree tempTree = new Tree(1);
-                        //null이 아니면 기존 노드 앞에 추가.
-                        if(treeInfo[nextX][nextY] != null){
-                            treeInfo[nextX][nextY].addTree(tempTree);
-                        }
-                        treeInfo[nextX][nextY] = tempTree;
-                    }
-                }
-            }
-
-            tree = tree.next;
-        }
-    }
-
-    //가을에 나무를 처리할 메서드 - 번식
-    private static void autumn(){
-
-        for(int i = 0; i < N; i++){
-            for(int j = 0; j < N; j++) {
-
-                breeding(i, j);
-
-            }
-        }
-    }
-    //겨울에 나무를 처리할 메서드 - 양분추가
-    private static void winter(){
-
-        for(int i = 0; i < N; i++){
-            for(int j = 0; j < N; j++){
-                maps[i][j] += nutrientMaps[i][j];
-            }
-        }
-
-    }
-
-    //살아있는 나무를 구할 메서드.
-    private static int findAliveTreeCount(){
-
-        int count = 0;
-
-        for(int i = 0; i < N ; i++){
-            for(int j = 0; j < N; j++){
-
-                Tree tree = treeInfo[i][j];
-
-                //노드가 있으면 반복해서 돌림.
-                while(tree != null){
-                    count++;
-                    tree = tree.next;
-                }
-            }
-        }
-
-        return count;
-
-    }
-
-    public static void main(String[] args) throws Exception{
-
-
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(br.readLine());
-
-        N = Integer.parseInt(st.nextToken());
-        M = Integer.parseInt(st.nextToken());
-        K = Integer.parseInt(st.nextToken());
-
-        maps = new int[N][N];
-        nutrientMaps = new int[N][N];
-        treeInfo = new Tree[N][N];
-
-        //땅과 나무 정보 배열 입력.
-        for(int i = 0; i < N; i++){
-            st = new StringTokenizer(br.readLine());
-
-            for(int j = 0; j < N; j++){
-                maps[i][j] = 5;
-                nutrientMaps[i][j] = Integer.parseInt(st.nextToken());
-            }
-        }
-
-        //초기 나무 입력
-        for(int i = 0; i < M; i++){
-            st = new StringTokenizer(br.readLine());
-
-            int x = Integer.parseInt(st.nextToken());
-            int y = Integer.parseInt(st.nextToken());
-            int z = Integer.parseInt(st.nextToken());
-
-            treeInfo[x - 1][y - 1] = new Tree(z);
-        }
-
-        //K년 동안 4계절 반복
-        while(K-- > 0){
-
-            //봄, 여름
-            springAndSummer();
-            //가을
-            autumn();
-            //겨울
-            winter();
-        }
-
-        //최종적으로 살아있는 나무의 수를 반환.
-        System.out.println(findAliveTreeCount());
-
-    }
-
-}
Index: minjae/week6/BOJ_4991_로봇청소기.java
===================================================================
diff --git a/minjae/week6/BOJ_4991_로봇청소기.java b/minjae/week6/BOJ_4991_로봇청소기.java
deleted file mode 100644
--- a/minjae/week6/BOJ_4991_로봇청소기.java	
+++ /dev/null	
@@ -1,122 +0,0 @@
-package week6;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-public class BOJ_4991_로봇청소기 {
-    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-    static StringTokenizer st;
-
-    static int N , M , Map[][] ,delta[][] = {{1,0},{0,1}, {-1,0},{0,-1}} , Max;
-
-
-    public static void main(String[] args) throws IOException {
-
-        while (true){
-            st = new StringTokenizer(br.readLine());
-            M = Integer.parseInt(st.nextToken());
-            N = Integer.parseInt(st.nextToken());
-            Max = Integer.MAX_VALUE;
-            if(M == 0 && N == 0)break;
-
-            int cnt = 0;
-            int idx = 0;
-            List<int[]> list = new ArrayList<>();
-            Map = new int[N][M];
-            for (int i = 0; i < N; i++) {
-                String s = br.readLine();
-                for (int j = 0; j < M; j++) {
-                    if (s.charAt(j) == '*') {
-                        Map[i][j] = 1;
-                        list.add(new int[]{i, j});
-                        cnt++;
-                    }else if (s.charAt(j) == 'x') {
-                        Map[i][j] = 2;
-                    }else if (s.charAt(j) == 'o'){
-                        Map[i][j] = 3;
-                        list.add(new int[]{i, j});
-                        idx = cnt;
-                        cnt++;
-                    }
-                }
-            }
-
-
-            int matrix[][] = new int[list.size()][list.size()];
-
-            for (int i = 0; i < list.size(); i++) {
-                int [][]dis = new int[N][M];
-                boolean [][]checked = new boolean[N][M];
-
-                Queue<int[]> queue = new LinkedList<>();
-                int start[] = list.get(i);
-                queue.add(new int[] {start[0] , start[1]});
-                checked[start[0]][start[1]] = true;
-
-                while (!queue.isEmpty()){
-                    int now[] = queue.poll();
-
-                    for (int j = 0; j < 4; j++) {
-                        int x = now[0] + delta[j][0];
-                        int y = now[1] + delta[j][1];
-
-                        if(x < 0 || x >=N || y < 0 || y >= M || checked[x][y] || Map[x][y] == 2) continue;
-                        queue.add(new int[]{x , y});
-                        dis[x][y] = dis[now[0]][now[1]] + 1;
-                        checked[x][y] = true;
-                    }
-                }
-
-                for (int j = 0; j < list.size(); j++) {
-                    if(i == j || matrix[i][j] != 0) continue;
-
-                    int temp[] = list.get(j);
-                    matrix[i][j] = dis[temp[0]][temp[1]];
-                    matrix[j][i] = dis[temp[0]][temp[1]];
-                }
-            }
-            boolean flag = false;
-            for(int i = 0 ; i < list.size() ; i++){
-                if( i == idx) continue;
-                if(matrix[idx][i] == 0){
-                    flag = true;
-                    break;
-                }
-            }
-
-            if(flag){
-                System.out.println(-1);
-                continue;
-            }
-
-            find(idx , 0,0 , matrix , new boolean[list.size()]);
-
-            System.out.println(Max);
-
-
-
-
-        }
-
-
-    }
-    static public void find(int start,int cnt, int result , int Matrix[][] , boolean []visited){
-        if (cnt == visited.length-1){
-            Max = Math.min(result, Max);
-            return;
-        }
-
-        visited[start] = true;
-        for(int i = 0 ; i < visited.length ; i++){
-            if(!visited[i]){
-                find(i , cnt+1 , result + Matrix[start][i], Matrix , visited);
-            }
-        }
-        visited[start] = false;
-
-    }
-
-
-}
\ No newline at end of file
Index: minjae/week4/BOJ_2580_스도쿠.java
===================================================================
diff --git a/minjae/week4/BOJ_2580_스도쿠.java b/minjae/week4/BOJ_2580_스도쿠.java
deleted file mode 100644
--- a/minjae/week4/BOJ_2580_스도쿠.java	
+++ /dev/null	
@@ -1,77 +0,0 @@
-package week4;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.StringTokenizer;
-
-public class BOJ_2580_스도쿠 {
-    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-    static StringTokenizer st;
-
-    static int N , Min, Max, M , K, X , P;
-    static int Map[][];
-    static boolean checked[][][];
-
-    static int delta[][] = {{0,1},{0,-1},{1,0},{-1,0},{0,0}};
-    public static void main(String[] args) throws NumberFormatException, IOException {
-        // TODO Auto-generated method stub
-
-        Map = new int[9][9];
-        checked = new boolean[3][10][10];
-
-       for(int i = 0 ; i < 9;i++){
-            st = new StringTokenizer(br.readLine());
-            for (int j = 0; j < 9 ; j++) {
-                Map[i][j] = Integer.parseInt(st.nextToken());
-
-                if(Map[i][j] != 0){
-                    checked[0][i][Map[i][j]] = true;
-                    checked[1][j][Map[i][j]] = true;
-
-                    checked[2][(i/3)*3 + j/3][Map[i][j]] = true;
-
-                }
-            }
-        }
-       findS(0);
-
-    }
-    static public void findS(int now){
-        if(now == 81){
-
-            for (int i = 0; i < 9; i++) {
-                for (int j = 0; j < 9; j++) {
-                    System.out.print(Map[i][j] + " ");
-                }
-                System.out.println();
-            }
-            System.exit(0);
-            return;
-        }
-        int x = now/9;
-        int y = now%9;
-
-
-        if(Map[x][y] != 0){
-            findS(now+1);
-        }else{
-            for(int i = 1; i<= 9 ; i ++){
-                if(!checked[0][x][i] && !checked[1][y][i] && !checked[2][(x/3)*3 + y/3][i]){
-                    checked[0][x][i] = true;
-                    checked[1][y][i]  = true;
-                    checked[2][(x/3)*3 + y/3][i]  = true;
-                    Map[x][y] = i;
-                    findS(now+1);
-                    Map[x][y] = 0;
-                    checked[0][x][i] = false;
-                    checked[1][y][i]  = false;
-                    checked[2][(x/3)*3 + y/3][i]  = false;
-                }
-            }
-        }
-
-
-    }
-
-}
\ No newline at end of file
Index: minjae/week6/BOJ_16987_계란으로계란치기.java
===================================================================
diff --git a/minjae/week6/BOJ_16987_계란으로계란치기.java b/minjae/week6/BOJ_16987_계란으로계란치기.java
deleted file mode 100644
--- a/minjae/week6/BOJ_16987_계란으로계란치기.java	
+++ /dev/null	
@@ -1,80 +0,0 @@
-package week6;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.StringTokenizer;
-
-public class BOJ_16987_계란으로계란치기 {
-    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-    static StringTokenizer st;
-
-    static int N , Min, Max, M , K, X , P;
-    static int Map[][];
-    static boolean checked[];
-
-    static int delta[][] = {{0,1},{0,-1},{1,0},{-1,0},{0,0}};
-    public static void main(String[] args) throws NumberFormatException, IOException {
-        // TODO Auto-generated method stub
-        N = Integer.parseInt(br.readLine());
-
-        Map = new int[N][2];
-        checked = new boolean[N];
-        Max = Integer.MIN_VALUE;
-        for (int i = 0; i < N ; i++) {
-            st = new StringTokenizer(br.readLine());
-            Map[i][0] = Integer.parseInt(st.nextToken());
-            Map[i][1] = Integer.parseInt(st.nextToken());
-        }
-
-
-
-        egg(0);
-        System.out.println(Max);
-
-
-    }
-
-    static public void egg(int cnt){
-        if(cnt == N){ // 끝
-            int result = 0;
-            for (int i = 0 ; i < N ;i++){
-                if(checked[i]){
-                    result++;
-                }
-            }
-            Max = Math.max(Max, result);
-            return;
-        }
-        if(!checked[cnt]){ // 손에 든 계란이 안 깨졌을경우
-            boolean flag = false;
-            for(int i = 0 ; i < N ;i++){
-                if(i != cnt && !checked[i]){
-                    flag = true;
-                    int handEgg = Map[cnt][0];
-                    int groundEgg = Map[i][0];
-
-                    Map[cnt][0] -= Map[i][1];
-                    Map[i][0] -= Map[cnt][1];
-                    checked[cnt] = Map[cnt][0] <= 0;
-                    checked[i] = Map[i][0] <= 0;
-
-                    egg(cnt + 1);
-
-                    Map[cnt][0] = handEgg;
-                    Map[i][0] = groundEgg;
-                    checked[cnt] = false;
-                    checked[i] = false;
-                }
-            }
-            if (!flag){  // 깰 계란이 없을때
-                egg(cnt + 1);
-            }
-        }else{ // 손에 든게 꺠졌을 경우
-            egg(cnt + 1);
-        }
-
-
-    }
-
-}
\ No newline at end of file
Index: minjae/Main.java
===================================================================
diff --git a/minjae/Main.java b/minjae/Main.java
deleted file mode 100644
--- a/minjae/Main.java	
+++ /dev/null	
@@ -1,120 +0,0 @@
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-public class Main {
-    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-    static StringTokenizer st;
-
-    static int N , M , Map[][] ,delta[][] = {{1,0},{0,1}, {-1,0},{0,-1}} , Max;
-
-
-    public static void main(String[] args) throws IOException {
-
-        while (true){
-            st = new StringTokenizer(br.readLine());
-            M = Integer.parseInt(st.nextToken());
-            N = Integer.parseInt(st.nextToken());
-            Max = Integer.MAX_VALUE;
-            if(M == 0 && N == 0)break;
-
-            int cnt = 0;
-            int idx = 0;
-            List<int[]> list = new ArrayList<>();
-            Map = new int[N][M];
-            for (int i = 0; i < N; i++) {
-                String s = br.readLine();
-                for (int j = 0; j < M; j++) {
-                    if (s.charAt(j) == '*') {
-                        Map[i][j] = 1;
-                        list.add(new int[]{i, j});
-                        cnt++;
-                    }else if (s.charAt(j) == 'x') {
-                        Map[i][j] = 2;
-                    }else if (s.charAt(j) == 'o'){
-                        Map[i][j] = 3;
-                        list.add(new int[]{i, j});
-                        idx = cnt;
-                        cnt++;
-                    }
-                }
-            }
-
-
-            int matrix[][] = new int[list.size()][list.size()];
-
-            for (int i = 0; i < list.size(); i++) {
-                int [][]dis = new int[N][M];
-                boolean [][]checked = new boolean[N][M];
-
-                Queue<int[]> queue = new LinkedList<>();
-                int start[] = list.get(i);
-                queue.add(new int[] {start[0] , start[1]});
-                checked[start[0]][start[1]] = true;
-
-                while (!queue.isEmpty()){
-                    int now[] = queue.poll();
-
-                    for (int j = 0; j < 4; j++) {
-                        int x = now[0] + delta[j][0];
-                        int y = now[1] + delta[j][1];
-
-                        if(x < 0 || x >=N || y < 0 || y >= M || checked[x][y] || Map[x][y] == 2) continue;
-                        queue.add(new int[]{x , y});
-                        dis[x][y] = dis[now[0]][now[1]] + 1;
-                        checked[x][y] = true;
-                    }
-                }
-
-                for (int j = 0; j < list.size(); j++) {
-                    if(i == j || matrix[i][j] != 0) continue;
-
-                    int temp[] = list.get(j);
-                    matrix[i][j] = dis[temp[0]][temp[1]];
-                    matrix[j][i] = dis[temp[0]][temp[1]];
-                }
-            }
-            boolean flag = false;
-            for(int i = 0 ; i < list.size() ; i++){
-                if( i == idx) continue;
-                if(matrix[idx][i] == 0){
-                    flag = true;
-                    break;
-                }
-            }
-
-            if(flag){
-                System.out.println(-1);
-                continue;
-            }
-
-            find(idx , 0,0 , matrix , new boolean[list.size()]);
-
-            System.out.println(Max);
-
-
-
-
-        }
-
-
-    }
-    static public void find(int start,int cnt, int result , int Matrix[][] , boolean []visited){
-        if (cnt == visited.length-1){
-            Max = Math.min(result, Max);
-            return;
-        }
-
-        visited[start] = true;
-        for(int i = 0 ; i < visited.length ; i++){
-            if(!visited[i]){
-                find(i , cnt+1 , result + Matrix[start][i], Matrix , visited);
-            }
-        }
-        visited[start] = false;
-
-    }
-
-
-}
\ No newline at end of file
Index: minjae/week6/BOJ_17281_야구.java
===================================================================
diff --git a/minjae/week6/BOJ_17281_야구.java b/minjae/week6/BOJ_17281_야구.java
deleted file mode 100644
--- a/minjae/week6/BOJ_17281_야구.java	
+++ /dev/null	
@@ -1,159 +0,0 @@
-package week6;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.StringTokenizer;
-
-public class BOJ_17281_야구 {
-    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-    static StringTokenizer st;
-
-    static int N , Min, Max, M , K, X , P;
-    static int Map[][];
-    static boolean checked[];
-
-    static int delta[][] = {{0,1},{0,-1},{1,0},{-1,0},{0,0}};
-    public static void main(String[] args) throws NumberFormatException, IOException {
-        // TODO Auto-generated method stub
-        N = Integer.parseInt(br.readLine());
-
-        Map = new int[N+1][10];
-        checked = new boolean[10];
-        Max = Integer.MIN_VALUE;
-
-        for (int i = 1; i <= N ; i++) {
-            st = new StringTokenizer(br.readLine());
-            for (int j = 1; j <= 9; j++) {
-                Map[i][j] = Integer.parseInt(st.nextToken());
-            }
-        }
-
-        int order[] = new int[10];
-        order[4] = 1;
-        checked[1] = true;
-        sequence(1 , order );
-        System.out.println(Max);
-    }
-
-    static public void sequence(int cnt , int order[]){
-        if(cnt == 10){ // 끝
-            Max = Math.max( culculate(order) , Max);
-            return;
-        }
-        if(cnt == 4){
-            sequence(cnt+1 ,order);
-        }else{
-            for (int i = 2; i <= 9 ; i++) {
-                if(!checked[i]){
-                    checked[i] = true;
-                    order[cnt] = i;
-                    sequence(cnt+1 , order);
-                    checked[i] = false;
-                }
-            }
-
-        }
-
-
-
-
-    }
-
-    static public int culculate(int[] order){
-        int idx = 1;
-        int sum = 0;
-        for(int i = 1; i <= N ; i++){
-            int out = 0;
-            int l[] = new int[5];
-            int inningScore = 0;
-            boolean[] base = new boolean[4];
-
-
-            while(out < 3) {
-                switch(Map[i][order[idx]]) {
-                    // 아웃
-                    case 0:
-                        out++;
-                        break;
-                    // 1루타
-                    case 1:
-                        if(base[3]) {
-                            inningScore++;
-                            base[3] = false;
-                        }
-                        if(base[2]) {
-                            base[3] = true;
-                            base[2] = false;
-                        }
-                        if(base[1]) {
-                            base[2] = true;
-                        }
-                        base[1] = true;
-                        break;
-                    // 2루타
-                    case 2:
-                        if(base[3]) {
-                            inningScore++;
-                            base[3] = false;
-                        }
-                        if(base[2]) {
-                            inningScore++;
-                        }
-                        if(base[1]) {
-                            base[3] = true;
-                            base[1] = false;
-                        }
-                        base[2] = true;
-                        break;
-                    // 3루타
-                    case 3:
-                        if(base[3]) {
-                            inningScore++;
-                        }
-                        if(base[2]) {
-                            inningScore++;
-                            base[2] = false;
-                        }
-                        if(base[1]) {
-                            inningScore++;
-                            base[1] = false;
-                        }
-                        base[3] = true;
-                        break;
-                    // 홈런
-                    case 4:
-                        if(base[3]) {
-                            inningScore++;
-                            base[3] = false;
-                        }
-                        if(base[2]) {
-                            inningScore++;
-                            base[2] = false;
-                        }
-                        if(base[1]) {
-                            inningScore++;
-                            base[1] = false;
-                        }
-                        inningScore++;
-                        break;
-                }
-
-                // 다음 타자로
-                idx++;
-                // 만약 10번 타자가 되면 다시 1번 타자로 되돌림
-                if(idx >= 10) {
-                    idx = 1;
-                }
-            }
-
-            // 해당 이닝에서 얻은 점수를 총 게임 점수에 더해줌
-            sum += inningScore;
-
-        }
-
-
-        return sum;
-    }
-
-}
\ No newline at end of file
Index: minjae/week7/BOJ_2212_센서.java
===================================================================
diff --git a/minjae/week7/BOJ_2212_센서.java b/minjae/week7/BOJ_2212_센서.java
deleted file mode 100644
--- a/minjae/week7/BOJ_2212_센서.java	
+++ /dev/null	
@@ -1,42 +0,0 @@
-package week7;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.Arrays;
-import java.util.PriorityQueue;
-import java.util.StringTokenizer;
-
-public class BOJ_2212_센서 {
-    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-    static StringTokenizer st;
-
-    static int N , K;
-
-    public static void main(String[] args) throws IOException {
-        N = Integer.parseInt(br.readLine());
-        K = Integer.parseInt(br.readLine());
-        int []arr = new int[N];
-
-        st = new StringTokenizer(br.readLine());
-
-        for (int i = 0; i < N; i++) {
-            arr[i] = Integer.parseInt(st.nextToken());
-        }
-
-        Arrays.sort(arr);
-
-        PriorityQueue<Integer> pq = new PriorityQueue<>();
-
-        for (int i = 1; i < N; i++) {
-            pq.add(arr[i] - arr[i-1]);
-        }
-        int result = 0;
-        for(int i = 0 ; i < N - K ; i++){
-            result += pq.poll();
-        }
-
-        System.out.println(result);
-
-    }
-}
\ No newline at end of file
Index: lsh9672/src/week07/BOJ2212_센서.java
===================================================================
diff --git a/lsh9672/src/week07/BOJ2212_센서.java b/lsh9672/src/week07/BOJ2212_센서.java
deleted file mode 100644
--- a/lsh9672/src/week07/BOJ2212_센서.java	
+++ /dev/null	
@@ -1,58 +0,0 @@
-package week07;
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.util.Arrays;
-import java.util.StringTokenizer;
-
-/**
- * 아이디어
- * 그리디 문제.
- * 각 센서별 구간을 구한다.
- * 집중국이 수신가능한 영역은 센서별 구간의 합이다 -> 1개일때
- * 그렇다면 이 수신가능한 영역의 합이 최소가 되려면, 가장 큰값을 빼주면 된다.
- * 집중국이 1개라면 수신가능한 영역의 길이의 합은 센서간 구간의 합이다.
- * 2개가 된다면, 영역을 두개로 나눌 수 있다. 즉, 가장 긴 구간 하나를 스킵할 수 있다는 뜻이된다.
- * 3개가 된다면 영역을 3개로 나눌 수 있다. 즉, 가장 긴 구간 2개를 스킵할 수 있다는 뜻이된다.
- * 예제를 보면 1 3 6 6 7 9 센서가 존재한다.
- * 이 센서간 구간길이를 구하면, 2 3 0 1 2가 된다.
- * 만약 집중국이 하나라면 모든 센서를 수신할 수 있는 영역의 길이의 합은 전체 합이 된다.
- * 하지만 집중국이 두개면 영역을 분리 할 수 있기 때문에 이중 구간하나를 제거할 수 있다
- * 합이 최소가 되야 하기 떄문에 가장 큰 값인 3을 제거하면 된다 -> 답 5
- */
-public class BOJ2212_센서 {
-    public static void main(String[] args) throws Exception{
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st;
-
-        int N = Integer.parseInt(br.readLine());
-        int K = Integer.parseInt(br.readLine());
-
-        int result = 0;
-
-        int[] sensorArray = new int[N]; //센서위치 정보 저장할 배열
-        int[] sectionArray = new int[N - 1]; //센서 구간 값 저장할 배열
-
-        st = new StringTokenizer(br.readLine());
-        for(int i = 0; i < N; i++){
-            sensorArray[i] = Integer.parseInt(st.nextToken());
-        }
-
-        Arrays.sort(sensorArray);
-
-        //구간 값 저장.
-        int sectionIndex = 0;
-        for(int i = 1; i < N; i++){
-            sectionArray[sectionIndex++] = Math.abs(sensorArray[i] - sensorArray[i - 1]);
-        }
-
-        //구간값 정렬
-        Arrays.sort(sectionArray);
-        for(int i = 0; i < N - 1 - (K - 1); i++){
-            result += sectionArray[i];
-        }
-
-        System.out.println(result);
-
-    }
-}
Index: lsh9672/src/week08/BOJ7576_토마토.java
===================================================================
diff --git a/lsh9672/src/week08/BOJ7576_토마토.java b/lsh9672/src/week08/BOJ7576_토마토.java
deleted file mode 100644
--- a/lsh9672/src/week08/BOJ7576_토마토.java	
+++ /dev/null	
@@ -1,139 +0,0 @@
-package week08;
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.lang.reflect.Array;
-import java.util.ArrayDeque;
-import java.util.Arrays;
-import java.util.Queue;
-import java.util.StringTokenizer;
-
-/**
- * 아이디어
- * 익은 토마토 위치를 큐에 넣고 bfs를 돌림.
- * -1이면 이동이 불가능하고, 이동할때마다 값을 증가시킴
- * 최종적으로 모든 토마토를 퍼트렸으면, 그 중 최대 값을 찾아서 저장함.
- */
-
-public class BOJ7576_토마토 {
-
-    private final static int[] dx = {-1, 1, 0, 0};
-    private final static int[] dy = {0, 0, -1, 1};
-
-    private static class Node{
-        private int x, y, time;
-
-        public Node(int x, int y, int time){
-            this.x = x;
-            this.y = y;
-            this.time = time;
-        }
-
-        public int getX() {
-            return x;
-        }
-
-        public int getY() {
-            return y;
-        }
-
-        public int getTime() {
-            return time;
-        }
-    }
-
-    private static int M;
-    private static int N;
-
-    private static int[][] maps;
-
-    private static void print(int[][] visited){
-
-        for(int i = 0; i  < N; i++){
-            System.out.println(Arrays.toString(visited[i]));
-        }
-
-        System.out.println("+++++++++++++++++");
-    }
-
-    private static int minDay(int[][] visited){
-
-        int minValue = -1;
-
-        for(int i = 0; i < N; i++){
-            for(int j = 0; j < M; j++){
-
-                if(maps[i][j] == -1) continue;
-
-                if(visited[i][j] == 0) return -1;
-
-                minValue = Math.max(minValue, visited[i][j]);
-
-            }
-        }
-
-        return minValue - 1;
-    }
-
-    private static boolean check(int nextX, int nextY, int[][] visited){
-
-        return nextX >= 0 && nextX < N &&
-                nextY >= 0 && nextY < M &&
-                visited[nextX][nextY] == 0 &&
-                maps[nextX][nextY] != -1;
-    }
-
-
-    private static int[][] bfs(Queue<Node> needVisited, int[][] visited){
-
-
-        while(!needVisited.isEmpty()){
-
-            Node currentNode = needVisited.poll();
-
-            for(int i = 0; i < 4; i++){
-
-                int nextX  = currentNode.getX() + dx[i];
-                int nextY = currentNode.getY() + dy[i];
-
-                if(check(nextX, nextY, visited)){
-                    visited[nextX][nextY] = currentNode.getTime() + 1;
-                    needVisited.add(new Node(nextX, nextY, currentNode.getTime() + 1));
-                }
-            }
-        }
-
-        return visited;
-
-    }
-
-    public static void main(String[] args) throws Exception{
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(br.readLine());
-
-        M = Integer.parseInt(st.nextToken());
-        N = Integer.parseInt(st.nextToken());
-
-        maps = new int[N][M];
-
-        Queue<Node> needVisited = new ArrayDeque<>();
-        int[][] visited = new int[N][M];
-        for(int i = 0; i < N; i++){
-            st = new StringTokenizer(br.readLine());
-
-            for(int j = 0; j < M; j++){
-
-                maps[i][j] = Integer.parseInt(st.nextToken());
-
-                if(maps[i][j] == 1){
-                    needVisited.add(new Node(i, j, 1));
-                    visited[i][j] = 1;
-                }
-            }
-        }
-
-        System.out.println(minDay(bfs(needVisited, visited)));
-
-
-    }
-}
Index: minjae/week3/BOJ_2589_보물섬.java
===================================================================
diff --git a/minjae/week3/BOJ_2589_보물섬.java b/minjae/week3/BOJ_2589_보물섬.java
deleted file mode 100644
--- a/minjae/week3/BOJ_2589_보물섬.java	
+++ /dev/null	
@@ -1,74 +0,0 @@
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-public class BOJ_2589_보물섬 {
-	static int N, M, Max = Integer.MIN_VALUE;
-	static boolean Map[][];
-	static class Node{
-		int x;
-		int y;
-		int dis;
-		public Node(int x, int y, int dis){
-			this.x = x;
-			this.y = y;
-			this.dis = dis;
-		}
-	}
-	static int[][] delta = {{1,0},{0,1},{-1,0},{0,-1}};
-	public static void main(String[] args) throws IOException {
-		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st = new StringTokenizer(br.readLine());
-		N = Integer.parseInt(st.nextToken());
-		M = Integer.parseInt(st.nextToken());
-
-		Map = new boolean[N][M];
-
-		for(int i = 0 ; i < N; i++){
-			String s = br.readLine();
-			for(int j = 0 ; j < M ; j++){
-				if(s.charAt(j) == 'L'){
-					Map[i][j] = true;
-				}
-			}
-		}
-
-
-		for(int i = 0 ; i < N; i++){
-			for(int j = 0 ; j < M ; j++){
-
-				if(Map[i][j]){
-					bfs(i,j);
-				}
-
-			}
-		}
-
-		System.out.println(Max);
-	}
-	static public void bfs(int x , int y){
-		boolean visited[][] =new boolean[N][M];
-
-		Queue<Node> queue = new LinkedList<>();
-		queue.add(new Node(x,y,0));
-		visited[x][y] = true;
-
-		while(!queue.isEmpty()){
-			Node now = queue.poll();
-			Max = Math.max(now.dis, Max);
-
-			for(int i = 0 ; i < delta.length ; i++){
-				int nextX = now.x + delta[i][0];
-				int nextY = now.y + delta[i][1];
-				if(nextX < 0 || nextX >= N || nextY <0 || nextY >=M) continue;
-				if(!Map[nextX][nextY] || visited[nextX][nextY]) continue;
-				queue.add(new Node(nextX,nextY,now.dis+1));
-				visited[nextX][nextY] = true;
-
-			}
-
-		}
-
-	}
-}
\ No newline at end of file
Index: chansik/src/week07/BOJ_2143_두배열의합.java
===================================================================
diff --git a/chansik/src/week07/BOJ_2143_두배열의합.java b/chansik/src/week07/BOJ_2143_두배열의합.java
deleted file mode 100644
--- a/chansik/src/week07/BOJ_2143_두배열의합.java	
+++ /dev/null	
@@ -1,81 +0,0 @@
-package chansik.src.week07;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-public class BOJ_2143_두배열의합 {
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(bf.readLine());
-        HashMap<Integer, Integer> map = new HashMap<>();
-        int t = Integer.parseInt(st.nextToken());
-        st = new StringTokenizer(bf.readLine());
-        int n = Integer.parseInt(st.nextToken());
-        int[] arr = new int[n];
-        st = new StringTokenizer(bf.readLine());
-        for(int i=0;i<n;i++) arr[i] = Integer.parseInt(st.nextToken());
-        st = new StringTokenizer(bf.readLine());
-        int m = Integer.parseInt(st.nextToken());
-        int[] brr = new int[m];
-        st = new StringTokenizer(bf.readLine());
-        long count = 0;
-        for(int i=0;i<m;i++) brr[i] = Integer.parseInt(st.nextToken());
-
-        List<int[]> aList = new ArrayList<>();
-        List<int[]> bList = new ArrayList<>();
-        int[] aSum = new int[n+1];
-        int[] bSum = new int[m+1];
-        for(int i=1;i<=n;i++) aSum[i] = aSum[i-1] + arr[i-1];
-        for(int i=1;i<=m;i++) bSum[i] = bSum[i-1] + brr[i-1];
-
-        for(int i=1;i<=n;i++) {
-            for (int j = 0; j < i; j++) {
-                int number = aSum[i] - aSum[j];
-                map.put(number, map.getOrDefault(number, 0) + 1);
-            }
-        }
-
-        for (int key : map.keySet()) aList.add(new int[]{key, map.get(key)});
-        map.clear();
-
-        for(int i=1;i<=m;i++) {
-            for (int j = 0; j < i; j++) {
-                int number = bSum[i] - bSum[j];
-                map.put(number, map.getOrDefault(number, 0) + 1);
-            }
-        }
-
-        for (int key : map.keySet()) bList.add(new int[]{key, map.get(key)});
-
-        Collections.sort(aList, (o1, o2) -> o1[0] - o2[0]);
-        Collections.sort(bList, (o1, o2) -> o1[0] - o2[0]);
-        for(int i=0;i<aList.size();i++) {
-            int[] frInfo = aList.get(i);
-            int frNum = frInfo[0]; int frCnt = frInfo[1];
-            int left = 0; int right = bList.size() - 1;
-            int middle = -1;
-            while(true) {
-                if (left > right) break;
-                middle = (right + left) / 2;
-
-                int[] reInfo = bList.get(middle);
-                int reNum = reInfo[0]; int reCnt = reInfo[1];
-
-                if (frNum + reNum > t) {
-                    right = middle - 1;
-                } else {
-                    left = middle + 1;
-                    if (frNum + reNum == t) {
-                        count += ((long) frCnt * reCnt);
-                        break;
-                    }
-                }
-
-            }
-        }
-
-        System.out.println(count);
-    }
-}
\ No newline at end of file
Index: chansik/src/week06/BOJ_1937_욕심쟁이판다.java
===================================================================
diff --git a/chansik/src/week06/BOJ_1937_욕심쟁이판다.java b/chansik/src/week06/BOJ_1937_욕심쟁이판다.java
deleted file mode 100644
--- a/chansik/src/week06/BOJ_1937_욕심쟁이판다.java	
+++ /dev/null	
@@ -1,53 +0,0 @@
-package chansik.src.week06;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.LinkedList;
-import java.util.PriorityQueue;
-import java.util.Queue;
-import java.util.StringTokenizer;
-
-public class BOJ_1937_욕심쟁이판다 {
-    static int[][] move = {{-1,0},{1,0},{0,1},{0,-1}};
-    static int ans = 1;
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(bf.readLine());
-        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o2[2] - o1[2]);
-        int n = Integer.parseInt(st.nextToken());
-        int[][] map = new int[n][n];
-        int[][] dp = new int[n][n];
-        for(int i=0;i<n;i++) {
-            st = new StringTokenizer(bf.readLine());
-            for(int j=0;j<n;j++) {
-                map[i][j] = Integer.parseInt(st.nextToken());
-                pq.add(new int[]{i, j, map[i][j]});
-            }
-        }
-
-        while(!pq.isEmpty()) {
-            int[] info = pq.poll();
-            int r = info[0]; int c = info[1]; int weight = info[2];
-            int max = 0;
-            for(int i=0;i<4;i++) {
-                int nr = r + move[i][0];
-                int nc = c + move[i][1];
-                if (isCheck(nr, nc, n)) {
-                    if (map[nr][nc] > weight && dp[nr][nc] > max) {
-                        max = dp[nr][nc];
-                    }
-                }
-            }
-            dp[r][c] = max + 1;
-        }
-
-        for(int i=0;i<n;i++)
-            for(int j=0;j<n;j++) ans = Math.max(ans, dp[i][j]);
-        System.out.println(ans);
-    }
-
-    public static boolean isCheck(int r, int c, int n) {
-        return r >= 0 && r < n && c >= 0 && c < n;
-    }
-}
Index: minjae/week5/BOJ_2011_암호코드.java
===================================================================
diff --git a/minjae/week5/BOJ_2011_암호코드.java b/minjae/week5/BOJ_2011_암호코드.java
deleted file mode 100644
--- a/minjae/week5/BOJ_2011_암호코드.java	
+++ /dev/null	
@@ -1,40 +0,0 @@
-package week5;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-
-public class BOJ_2011_암호코드 {
-    static int Max , Map[], DP[];
-    public static void main(String[] args) throws IOException {
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        String s = br.readLine();
-        Map = new int [s.length()+1];
-        DP = new int [s.length()+1];
-        for(int i = 0 ; i< s.length() ; i++){
-            Map[i] = s.charAt(i) - '0';
-            if(Map[i] < 0 || Map[i] > 9) return;
-        }
-
-        if(Map[0] == 0) {
-            System.out.println(0);
-            return;
-        }
-
-        DP[0] = 1;
-        DP[1] = 1;
-        for(int i=1; i<s.length(); i++) {
-            char pri = s.charAt(i - 1);
-            if(s.charAt(i) >= '1' && s.charAt(i)<='9'){
-                DP[i+1]+=DP[i];
-                DP[i+1]%=1000000;
-            }
-            if (!(pri == '0' || pri > '2' || (pri == '2' && s.charAt(i) > '6'))) {
-                DP[i + 1] += DP[i-1];
-                DP[i+1]%=1000000;
-            }
-            DP[i + 1] %= 1000000000;
-        }
-        System.out.println(DP[s.length()]%1000000000);
-    }
-}
\ No newline at end of file
Index: chansik/src/week07/BOJ_2212_센서.java
===================================================================
diff --git a/chansik/src/week07/BOJ_2212_센서.java b/chansik/src/week07/BOJ_2212_센서.java
deleted file mode 100644
--- a/chansik/src/week07/BOJ_2212_센서.java	
+++ /dev/null	
@@ -1,35 +0,0 @@
-package chansik.src.week07;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.StringTokenizer;
-
-public class BOJ_2212_센서 {
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(bf.readLine());
-        HashSet<Integer> set = new HashSet<>();
-        int n = Integer.parseInt(st.nextToken());
-        st = new StringTokenizer(bf.readLine());
-        int k = Integer.parseInt(st.nextToken());
-        st = new StringTokenizer(bf.readLine());
-        for(int i=0;i<n;i++) set.add(Integer.parseInt(st.nextToken()));
-        int[] arr = new int[set.size()];
-        int idx = 0;
-        for (int num : set) arr[idx++] = num;
-        Arrays.sort(arr);
-        int[] dist = new int[arr.length-1];
-        for(int i=1;i<arr.length;i++) dist[i-1] = arr[i] - arr[i-1];
-        Arrays.sort(dist);
-        int sum = Arrays.stream(dist).sum();
-        for(int index=dist.length-1, count=k-1;count>0;count--,index--) {
-            if (index < 0) break;
-            sum -= dist[index];
-        }
-        System.out.print(sum);
-    }
-}
\ No newline at end of file
Index: lsh9672/src/week07/BOJ16988_Baaaaaaaaaduk2_Easy.java
===================================================================
diff --git a/lsh9672/src/week07/BOJ16988_Baaaaaaaaaduk2_Easy.java b/lsh9672/src/week07/BOJ16988_Baaaaaaaaaduk2_Easy.java
deleted file mode 100644
--- a/lsh9672/src/week07/BOJ16988_Baaaaaaaaaduk2_Easy.java	
+++ /dev/null	
@@ -1,180 +0,0 @@
-package week07;
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.util.*;
-
-/**
- * 아이디어
- * 완탐 + 빡구현
- * 내 돌을 놓을 위치 두개를 구하고, 놓는다.
- * 상대 돌(2)위치를 잡고 bfs를 돌려서 중간에 빈칸이 있으면 패스, 탐색하는 동안 빈칸이 없으면 상대돌의 개수를 반환한다.
- */
-
-public class BOJ16988_Baaaaaaaaaduk2_Easy {
-    //사방탐색
-    private final static int[] dx = {-1, 1, 0, 0};
-    private final static int[] dy = {0, 0, -1, 1};
-
-    //탐색을 위한 노드
-    private static class Node{
-        private int x, y;
-
-        public Node(int x, int y){
-            this.x = x;
-            this.y = y;
-        }
-
-        public int getX() {
-            return x;
-        }
-
-        public int getY() {
-            return y;
-        }
-    }
-
-
-    //행
-    private static int N;
-    //열
-    private static int M;
-
-    //바둑돌을 놓을 위치 리스트
-    private static List<Node> emptyLocList;
-
-    //바둑판
-    private static int[][] maps;
-
-    //죽일 수 있는 돌의 최대 개수
-    private static int maxCount;
-
-    //재귀 돌리면서 2개 뽑기
-    private static void recursive(int index, int currentCount){
-
-        if(currentCount == 2){
-            int temp = logic();
-            maxCount = Math.max(maxCount, temp);
-
-            return;
-        }
-
-        for(int i = index; i < emptyLocList.size(); i++){
-
-            Node node = emptyLocList.get(i);
-
-            maps[node.getX()][node.getY()] = 1;
-            recursive(i + 1, currentCount + 1);
-            maps[node.getX()][node.getY()] = 0;
-
-        }
-
-    }
-
-    //방문 가능한지 체크하는 메서드
-    private static boolean check(int nextX, int nextY, boolean[][] visited){
-        return nextX >= 0 && nextX < N &&
-                nextY >= 0 && nextY < M &&
-                !visited[nextX][nextY];
-    }
-
-    //bfs돌리는 메서드
-    private static int bfs(Node startNode, boolean[][] visited){
-
-        Queue<Node> needVisited = new ArrayDeque<>();
-        needVisited.add(new Node(startNode.getX(), startNode.getY()));
-
-        //0이 아닌 수
-        int nonZeroCount = 0;
-        int zeroCount = 0;
-
-        while(!needVisited.isEmpty()){
-
-            Node currentNode = needVisited.poll();
-
-            //상대 돌 개수 세기.
-            nonZeroCount++;
-
-            for(int i = 0; i < 4; i++){
-                int nextX = currentNode.getX() + dx[i];
-                int nextY = currentNode.getY() + dy[i];
-
-                if(check(nextX, nextY, visited)){
-
-                    if(maps[nextX][nextY] == 1) continue;
-
-                    if(maps[nextX][nextY] == 0) {
-                        zeroCount++;
-                        continue;
-                    }
-                    visited[nextX][nextY] = true;
-                    needVisited.add(new Node(nextX, nextY));
-                }
-            }
-        }
-
-        if(zeroCount == 0) return nonZeroCount;
-        else return 0;
-    }
-
-    //2중 반복문으로 상대 바둑돌을 시작점으로 해서bfs 돌리기
-    private static int logic(){
-
-        int count = 0;
-        boolean[][] visited = new boolean[N][M];
-
-        for(int i = 0; i < N; i++){
-            for(int j = 0; j < M; j++){
-
-                //방문을 안했거나 상대돌이면.
-                if(maps[i][j] == 2 && !visited[i][j]){
-                    visited[i][j] = true;
-                    count += bfs(new Node(i,j), visited);
-                }
-            }
-        }
-
-
-        return count;
-    }
-
-    //빈 위치 구하기
-    private static void setEmptyLoc(){
-
-        for(int i = 0; i < N; i++){
-            for(int j = 0; j < M; j++){
-                if(maps[i][j] == 0){
-                    emptyLocList.add(new Node(i,j));
-                }
-            }
-        }
-
-    }
-
-
-    public static void main(String[] args) throws Exception{
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(br.readLine());
-
-        N = Integer.parseInt(st.nextToken());
-        M = Integer.parseInt(st.nextToken());
-
-        emptyLocList = new ArrayList<>();
-        maps = new int[N][M];
-        maxCount = 0;
-
-        for(int i = 0; i < N; i++){
-            st = new StringTokenizer(br.readLine());
-            for(int j = 0; j < M; j++){
-                maps[i][j] = Integer.parseInt(st.nextToken());
-            }
-        }
-
-        setEmptyLoc();
-
-        recursive(0,0);
-        System.out.println(maxCount);
-
-    }
-
-}
Index: lsh9672/src/week08/BOJ_17485_진우의_달_여행_Large.java
===================================================================
diff --git a/lsh9672/src/week08/BOJ_17485_진우의_달_여행_Large.java b/lsh9672/src/week08/BOJ_17485_진우의_달_여행_Large.java
deleted file mode 100644
--- a/lsh9672/src/week08/BOJ_17485_진우의_달_여행_Large.java	
+++ /dev/null	
@@ -1,108 +0,0 @@
-package week08;
-
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.util.Arrays;
-import java.util.StringTokenizer;
-
-/**
- * 아이디어
- * dp를 이용하여 처리.
- * 특정위치에 올수 있는 값들 중 최소가 되는 값을 저장.
- * 예를 들어 문제 예시에서 2,1이라고 한다면, 해당위치로 올 수 있는 경우의 수는, 6가지 이다.
- * 같은 방향으로 연속해서 이동은 불가능 하기 때문에, 현재 행에서 -2행 위치에서 계산해야 한다.
- *
- * 5,5 배열에서 2,2로 오기 위한 경우를 나열하면 다음과 같다.
- * 1. (0,1) -> (1,2) -> (2,2)
- * 2. (0,1) -> (1,1) -> (2,2)
- * 3. (0,2) -> (1,1) -> (2,2)
- * 4. (0,2) -> (1,3) -> (2,2)
- * 5. (0,3) -> (1,2) -> (2,2)
- * 6. (0,3) -> (1,3) -> (2,2)
- *
- * 3번째 칸부터 계산을 해주면 된다.
- *
- * (수정)
- * 위의 해설은 1%에서 틀렸다
- * 위의 방법으로 하면, 확인이 안되는 부분이 있다.
- * i를 구할 때, i-2위치 값은, dp 배열에서 가져오는데, 해당값이 어떤 방향으로 진입한 값인지 알수 없어,
- * 다음 연산시에 연속된 방향의 값을 선택하는 경우가 생긴다.
- * 이를 해결하기 위해서 3차원 배열로 해결한다.
- * 기존 값만 표시한 2차원 배열에서 차원을 추가해서 이전에 진입한 방향도 표시하여 처리하도록 한다.
- *
- */
-public class BOJ_17485_진우의_달_여행_Large {
-
-    //행
-    private static int N;
-    //렬
-    private static int M;
-    //지도
-    private static int[][] maps;
-    //누적할 dp 배열
-    private static int[][][] dp;
-    public static void main(String[] args) throws Exception{
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(br.readLine());
-
-        N = Integer.parseInt(st.nextToken());
-        M = Integer.parseInt(st.nextToken());
-
-        maps = new int[N][M];
-        dp = new int[N][M][3]; // 0: 왼쪽 아래, 1: 아래, 2: 오른쪽 아래.
-
-        for(int i = 0; i < N; i++){
-            st = new StringTokenizer(br.readLine());
-            for(int j = 0; j < M; j++){
-                maps[i][j] = Integer.parseInt(st.nextToken());
-            }
-        }
-
-        for(int i = 0; i < N; i++){
-            for(int j = 0; j < M; j++){
-                for(int dir = 0; dir < 3; dir++){
-                    dp[i][j][dir] = Integer.MAX_VALUE;
-                }
-            }
-        }
-
-        //최대 값 출력.
-        int result = Integer.MAX_VALUE;
-
-        //초기 값 저장 - 첫행
-        for(int i = 0; i < M; i++){
-            for(int j = 0; j < 3; j++){
-                dp[0][i][j] = maps[0][i];
-            }
-        }
-
-
-        //디피 계산 - 두번째 행부터 시작.
-        for(int i = 1; i < N; i++){
-            for(int j = 0; j < M; j++){
-
-                //0방향으로 들어올때,
-                if(j + 1 < M) dp[i][j][0] = maps[i][j] + Math.min(dp[i - 1][j + 1][1], dp[i - 1][j + 1][2]);
-
-                //1방향으로 들어올때,
-                dp[i][j][1] = maps[i][j] + Math.min(dp[i - 1][j][0], dp[i - 1][j][2]);
-
-                //2방향으로 들어올때,
-                if(j - 1 >= 0) dp[i][j][2] = maps[i][j] + Math.min(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1]);
-
-            }
-        }
-
-
-        for(int i = 0; i < M; i++){
-            for(int dir = 0; dir < 3; dir++){
-
-                result = Math.min(result, dp[N - 1][i][dir]);
-            }
-        }
-
-        System.out.println(result);
-
-    }
-}
Index: minjae/week2/BOJ_11559_puyopuyo.java
===================================================================
diff --git a/minjae/week2/BOJ_11559_puyopuyo.java b/minjae/week2/BOJ_11559_puyopuyo.java
deleted file mode 100644
--- a/minjae/week2/BOJ_11559_puyopuyo.java	
+++ /dev/null	
@@ -1,110 +0,0 @@
-package week2;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-public class BOJ_11559_puyopuyo {
-    static int N, M;
-    static int delta[][] = {{1,0},{0,1},{-1,0},{0,-1}};
-    static char Map[][];
-    public static void main(String[] args) throws IOException {
-
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        N =12 ;
-        M = 6;
-        Map = new char[N][M];
-
-        for(int i = 0 ; i < N ; i++){
-            String s = br.readLine();
-            for (int j = 0; j < M; j++) {
-                Map[i][j] = s.charAt(j);
-            }
-        }
-
-        List<Character>[] list = new List[M];
-
-        for(int i = 0 ; i < M ;i++){
-            list[i] = new ArrayList<Character>();
-            for (int j = 11 ; j >= 0 ; j--){
-                list[i].add(Map[j][i]);
-            }
-        }
-
-//        for(int i = 0 ; i < M ;i++){
-//
-//            for(char a : list[i]){
-//                System.out.print(a);
-//            }
-//            System.out.println();
-//        }
-
-        int cnt = 0;
-
-        while (true){
-
-            boolean checked[][] = new boolean[6][12];
-
-            PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {
-                @Override
-                public int compare(int[] o1, int[] o2) {
-                    return o2[1] - o1[1];
-                }
-            });
-
-            for(int i = 0 ; i < 6 ;i++){
-                for(int j = 0 ; j < list[i].size() ; j++){
-                    char std = list[i].get(j);
-                    if(std != '.' && !checked[i][j]){
-                        Queue<int[]> queue = new LinkedList<>();
-                        Queue<int[]> stock = new LinkedList<>();
-                        queue.add(new int[] {i , j});
-                        checked[i][j] = true;
-
-
-                        while(!queue.isEmpty()){
-                            int now[] = queue.poll();
-                            if(list[now[0]].get(now[1]) == std){
-                                stock.add(now);
-                            }
-                            for(int k = 0 ; k< 4 ; k++){
-                                int x = now[0] + delta[k][0];
-                                int y = now[1] + delta[k][1];
-                                if(x < 0 || x >= 6 || y < 0 || y >= 12 || checked[x][y]) continue;
-                                char puyo = list[x].get(y);
-                                if(puyo != std) continue;
-                                queue.add(new int[]{x , y});
-                                checked[x][y] = true;
-                            }
-                        }
-
-                        if(stock.size() >= 4){
-                            while (!stock.isEmpty()){
-                                pq.add(stock.poll());
-                            }
-                        }
-                    }
-                }
-            }
-
-            if(pq.size() == 0){
-                break;
-            }else{
-                cnt++;
-                while (!pq.isEmpty()){
-                    int funk[]  = pq.poll();
-                    list[funk[0]].remove(funk[1]);
-                    list[funk[0]].add('.');
-                }
-            }
-        }
-
-        System.out.println(cnt);
-
-
-
-
-
-    }
-}
\ No newline at end of file
Index: lsh9672/src/week08/BOJ1062_가르침.java
===================================================================
diff --git a/lsh9672/src/week08/BOJ1062_가르침.java b/lsh9672/src/week08/BOJ1062_가르침.java
deleted file mode 100644
--- a/lsh9672/src/week08/BOJ1062_가르침.java	
+++ /dev/null	
@@ -1,151 +0,0 @@
-package week08;
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.util.StringTokenizer;
-
-/**
- * 아이디어
- * 완탐을 이용한 문제
- *
- * 앞 뒤 4글자는 고정이라고 한다.
- * 선택할 수 있는 글자는 앞뒤 4글자를 제외한 글자가 된다.
- * 제외한 글자를 모으는 리스트를 만든다.
- * 해당 리스트에서 글자를 뽑고, 뽑을 수 있는 최대 개수만큼 뽑으면 각 문자열들과 비교해서 만들수 있는지 확인한다.
- *
- * (추가)
- * 이와 같은 방식으로, 모든 알파벳중에 K - 5개를 뽑는 경우가 아닌,앞뒤 4글자를 자르고 남은 알바펫중에서 뽑게 하면, K - 5개 미만으로 뽑았을때,
- * 가능한 문자의 경우에는 탐색을 안한다.
- * 그래서 재귀 조건에 K-5와 같거나 작은 경우, 체킹을 하도록 했고, k -5 를 넘어가게 고르면 종료하도록 했다.
- * 이전에 짰을때는 오든 알파벳중에서 5개를 뽑는 경우였는데, 이보다 5배정도 느렸다.
- * K-5개를 골랐을때가 아니라, K -5보다 작을때마다 체크를 해줘야하기 때문이다.
- */
-public class BOJ1062_가르침 {
-    //단어 개수
-    private static int N;
-
-    //가르칠 단어 개수
-    private static int K;
-
-    //단어 저장 리스트.
-    private static String[] wordArray;
-
-    //알파벳 방문 처리
-    private static boolean[] visited;
-
-    //공통 알파벳을 제외한, 뽑을 알파벳 리스트
-    private static boolean[] alphaArray;
-
-    //최대 개수 저장
-    private static int maxValue;
-
-    //초기 설정 잡는 메서드
-
-
-    //반복문 돌면서 몇개의 문자열까지 매칭 되는지 확인 후 개수 리턴하는 메서드
-    private static int matching(){
-
-        int returnCount = 0;
-
-        for(int i = 0; i < N; i++){
-            String word = wordArray[i];
-
-            boolean flag = true;
-
-            for(int j = 0; j < word.length(); j++){
-
-                if(!visited[word.charAt(j) - 'a']){
-                    flag = false;
-                    break;
-                }
-            }
-
-            if(flag) returnCount++;
-        }
-
-        return returnCount;
-    }
-
-    //재귀 돌면서 문자 뽑는 메서드.
-    private static void recursive(int index, int currentCount){
-
-        if(currentCount > K - 5) return;
-
-        //뽑아야 되는 최대 문자수 - (K - 5) 개만큼 뽑았으면 문자 매칭
-        if(currentCount <= K - 5){
-            maxValue = Math.max(maxValue, matching());
-        }
-
-
-        for(int i = index; i < 26; i++){
-
-            //false면 없는 알파벳
-            if(!alphaArray[i]) continue;
-
-            if(!visited[i]){
-                visited[i] = true;
-                recursive(i + 1, currentCount + 1);
-                visited[i] = false;
-            }
-        }
-
-    }
-
-    //초기 문자 넣어두기
-    private static void init(){
-
-        String initStr = "antic"; //이 문자들은 고정으로 사용되는 문자.
-
-        for(int i = 0; i < initStr.length(); i++){
-            char tempChr = initStr.charAt(i);
-
-            visited[tempChr - 'a'] = true;
-        }
-    }
-
-    public static void main(String[] args) throws Exception{
-
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(br.readLine());
-
-        N = Integer.parseInt(st.nextToken());
-        K = Integer.parseInt(st.nextToken());
-
-        wordArray = new String[N];
-        visited = new boolean[26];
-        alphaArray = new boolean[26];
-
-        //가르쳐야 하는 문자 수(K)가 5개 미만이면 그냥 종료
-        if(K < 5){
-            System.out.println(0);
-            return;
-        }
-
-        init();
-
-        for(int i = 0; i < N; i++){
-
-            //앞 뒤 4자리를 뺴고 나머지 문자 저장.
-            String temp = br.readLine();
-
-            temp = temp.substring(4, temp.length() - 4);
-
-            //배열에 넣고,
-            wordArray[i] = temp;
-
-            //해당 문자를 반복문 돌면서 문자 선택을 위한 리스트에 저장 - 조합으로 뽑을 문자 저장.
-            for(int j = 0; j < temp.length(); j++){
-                char tempChr = temp.charAt(j);
-
-                alphaArray[tempChr - 'a'] = true;
-            }
-        }
-
-        maxValue = 0;
-
-        recursive(0,0);
-
-        System.out.println(maxValue);
-
-    }
-}
Index: minjae/week2/BOJ_9251_LCS.java
===================================================================
diff --git a/minjae/week2/BOJ_9251_LCS.java b/minjae/week2/BOJ_9251_LCS.java
deleted file mode 100644
--- a/minjae/week2/BOJ_9251_LCS.java	
+++ /dev/null	
@@ -1,50 +0,0 @@
-package week2;
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-
-public class BOJ_9251_LCS {
-
-	public static void main(String[] args) throws IOException {
-		// TODO Auto-generated method stub
-		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-		String N = br.readLine();
-		String M = br.readLine();
-
-		char first[] = new char[N.length()];
-		char second[] = new char[M.length()];
-
-		for (int i = 0; i < first.length; i++) {
-			first[i] = N.charAt(i);
-		}
-		for (int i = 0; i < second.length; i++) {
-			second[i] = M.charAt(i);
-		}
-
-		int DP[][] = new int[N.length() + 1][M.length() + 1];
-
-		for (int i = 1; i <= N.length(); i++) {
-			for (int j = 1; j <= M.length(); j++) {
-				if (first[i - 1] == second[j - 1]) {
-					DP[i][j] = DP[i - 1][j-1] + 1;
-				} else {
-					DP[i][j] = Math.max(DP[i - 1][j], DP[i][j - 1]);
-				}
-
-			}
-		}
-
-//		for(int i = 0 ; i <= N.length() ;i++) {
-//			for(int j = 0 ; j <= M.length(); j++) {
-//				
-//				System.out.print(DP[i][j] + " ");
-//				
-//			}
-//			System.out.println();
-//		}
-//		
-
-		System.out.println(DP[N.length()][M.length()]);
-	}
-
-}
\ No newline at end of file
Index: minjae/week3/BOJ_3190_뱀.java
===================================================================
diff --git a/minjae/week3/BOJ_3190_뱀.java b/minjae/week3/BOJ_3190_뱀.java
deleted file mode 100644
--- a/minjae/week3/BOJ_3190_뱀.java	
+++ /dev/null	
@@ -1,94 +0,0 @@
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.Arrays;
-import java.util.StringTokenizer;
-
-public class BOJ_3190_뱀{
-
-    static int N;
-    static boolean Map[][][];
-    static int change[][];
-    static int delta[][] = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };
-
-    public static void main(String[] args) throws NumberFormatException, IOException {
-        // TODO Auto-generated method stub
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st;
-        N = Integer.parseInt(br.readLine());
-
-        Map = new boolean[N + 1][N + 1][2];
-
-        int k = Integer.parseInt(br.readLine());
-        for (int i = 1; i <= k; i++) {
-            st = new StringTokenizer(br.readLine());
-            Map[Integer.parseInt(st.nextToken())][Integer.parseInt(st.nextToken())][1] = true;
-        }
-
-
-        int l = Integer.parseInt(br.readLine());
-        change = new int[l][2];
-        int num = 0;
-
-        for (int i = 0; i < l; i++) {
-            st = new StringTokenizer(br.readLine());
-            int a = Integer.parseInt(st.nextToken());
-            String b = st.nextToken();
-            if (b.equals("D")) {
-                num = (num + 1) % 4;
-            } else if(b.equals("L")) {
-                num = num - 1 < 0 ? 3 : num - 1;
-            }
-            change[i][0] = a;
-            change[i][1] = num;
-
-
-        }
-
-
-        int cnt = 0;
-        int cnt_t = 0;
-        int del = 0;
-        int del_t = 0;
-        int tailX = 1;
-        int tailY = 1;
-        int nextX = 1;
-        int nextY = 1;
-
-        int check = 0;
-        int check_t = 0;
-
-        while (true) {
-            Map[nextX][nextY][0] = true;
-
-            if(check_t < l && cnt_t == change[check_t][0]  ) {
-                del_t = change[check_t][1];
-                check_t++;
-            }
-            if(check < l && cnt == change[check][0] ) {
-                del = change[check][1];
-                check++;
-            }
-
-            nextX = nextX + delta[del][0];
-            nextY = nextY + delta[del][1];
-
-            if (nextX < 1 || nextY < 1 || nextX > N || nextY > N || Map[nextX][nextY][0])
-                break;
-            //System.out.println(nextX + " " + nextY + " : " + change[cnt]);
-
-            if (Map[nextX][nextY][1]) {
-                Map[nextX][nextY][1] = false;
-            } else {
-                Map[tailX][tailY][0] = false;
-                tailX = tailX + delta[del_t][0];
-                tailY = tailY + delta[del_t][1];
-                cnt_t++;
-            }
-            cnt++;
-        }
-
-        System.out.println(cnt+1);
-    }
-
-}
\ No newline at end of file
Index: lsh9672/src/week06/BOJ4991_로봇청소기.java
===================================================================
diff --git a/lsh9672/src/week06/BOJ4991_로봇청소기.java b/lsh9672/src/week06/BOJ4991_로봇청소기.java
deleted file mode 100644
--- a/lsh9672/src/week06/BOJ4991_로봇청소기.java	
+++ /dev/null	
@@ -1,250 +0,0 @@
-package week06;
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.sql.Array;
-import java.util.*;
-
-/**
- *
- * 먼지 == 더러운 칸
- * 아이디어1
- * 순열을 이용한 백트래킹 문제
- * 어떤 먼지를 먹었을때, 최소가 되는지는 모든 경우를 해보기 전까지는 알 수 없다 -> 그리디X
- * 모든 먼지 위치를 리스트에 넣고, 순열을 이용해서 순서를 뽑는다.
- * 해당 위치까지는 bfs탐색으로 최단 거리를 구하고, 매번 bfs탐색시마다 방문 배열을 초기화 해서 방문했던 곳을 다시 가도록 한다.
- * 방문했던곳을 또 방문 할 수 있다고 되어있지만, 특정 위치에서 먼지가 있는 위치까지 이동할 때는 방문했던 곳을 방문하지 않는 것이 최단거리가 된다.
- * 먼지를 치우고, 해당 위치에서 다른 먼지로 갈때는 방문배열이 초기화 되도록 하면 된다.
- *
- * 아이디어2(실패)
- * 단순 bfs문제
- * 단 bfs로 풀 때는 갔던 곳을 또 갈 수 있기 때문에, 방문처리를 잘해야 한다.
- * 방문처리 배열을 3차원으로 만들고 그중 파라미터 하나는 먹은 먼지 수로 해서,
- * 매번 먼지를 먹을때마다 방문처리배열이 마치 초기화 되듯이 짠다.
- * 이 케이스는 현재위치에서 가장 가까운 위치의 먼지부터 순차 탐색하는 그리디이므로 오답이다
- * 가령 A,B,C 노드가 존재한다 가정하고, C로가야 한다 했을떄, 초기 위치에서 A까지가 최소이지만, A에서 C가 최대라 결과가 최대가 될 수도 있다.
- * 2(A) + 7(C) vs 3(B) + 5(C)
- */
-
-public class BOJ4991_로봇청소기 {
-
-    //방문시에 사용할 4방 탐색용 배열.
-    private static final int[] dx = {-1, 1, 0, 0};
-    private static final int[] dy = {0, 0, -1, 1};
-
-    //bfs탐색시에 사용할 노드 객체
-    private static class Node{
-        private int x, y, count;
-
-        public Node(int x, int y, int count){
-            this.x = x;
-            this.y = y;
-            this.count = count;
-        }
-        public Node(int x, int y){
-            this.x = x;
-            this.y = y;
-        }
-
-        public int getX() {
-            return x;
-        }
-
-        public int getY() {
-            return y;
-        }
-
-        public int getCount() {
-            return count;
-        }
-
-        public Node newNode(){
-            return new Node(this.x, this.y, 0);
-        }
-
-        public boolean sameCheck(Node node){
-            return this.x == node.getX() &&
-                    this.y == node.getY();
-        }
-
-        @Override
-        public String toString() {
-            return "Node{" +
-                    "x=" + x +
-                    ", y=" + y +
-                    ", count=" + count +
-                    '}';
-        }
-    }
-
-    //가로 크기
-    private static int W;
-    //세로 크기
-    private static int H;
-    //최소 이동횟수 저장.
-    private static int minMoveCount;
-    //재귀 탐색시에 이미 방문한 먼지 위치인지 판단하는 배열
-    private static boolean[] dirtyVisited;
-    //격자형 그래프
-    private static char[][] maps;
-    //먼지 위치 저장 리스트.
-    private static List<Node> dirtyList;
-    //bfs탐색시에 배열을 벗어나지 않는지 체크하는 메서드
-    private static boolean check(int nextX, int nextY, boolean[][] visited){
-        return nextX >= 0 && nextX < H &&
-                nextY >= 0 && nextY < W &&
-                !visited[nextX][nextY];
-    }
-
-    //bfs탐색 메서드 - 이동거리를 반환해야 한다.
-    private static int bfs(Node startNode, Node endNode){
-
-//        System.out.println("startNode : " + startNode);
-//        System.out.println("endNode : " + endNode);
-
-        boolean[][] visited = new boolean[H][W];
-        visited[startNode.getX()][startNode.getY()] = true;
-
-        Queue<Node> needVisited = new ArrayDeque<>();
-        needVisited.add(startNode.newNode());
-
-        while(!needVisited.isEmpty()){
-
-            Node currentNode = needVisited.poll();
-
-            if(currentNode.sameCheck(endNode)){
-
-                return currentNode.getCount();
-            }
-
-            for(int i = 0; i < 4; i++){
-                int nextX = currentNode.getX() + dx[i];
-                int nextY = currentNode.getY() + dy[i];
-
-                if(check(nextX, nextY, visited) && maps[nextX][nextY] != 'x'){
-                    visited[nextX][nextY] = true;
-                    needVisited.add(new Node(nextX,nextY, currentNode.getCount() + 1));
-                }
-            }
-
-        }
-
-        //이동이 불가능 하면 -1.
-        return -1;
-    }
-
-    //재귀 돌면서 방문할 먼지 순서를 정하는 메서드 - 매번 탐색할 먼지위치를 뽑고, bfs를 돌려서 새로운 위치를 넣고 재귀돌림
-    //모든 먼지를 방문하면 최소값 계산, 탐색중에 이전에 저장한 최소이동횟수보다 커지면 가지치기.
-    //방문할 수 없으면 false값을 리턴해서 재귀 종료시킴.
-    private static boolean recursive(Node robotLocation,int index, int moveCount){
-
-//        System.out.println("index : " + index + ", " + robotLocation + ", " + moveCount);
-
-        //이전에 저장한 최소이동값보다 현재값이 같거나 크면 패스
-        if(moveCount >= minMoveCount) return true;
-
-        //moveCount에 값이 -1이면 해당 위치로 갈 수 없다는 뜻이므로 false 리턴
-        if(moveCount == -1) return false;
-
-        //index가 먼지 개수에 도달하면, 모든 먼지를 탐색했다는 뜻이므로, 업데이트
-        if(index >= dirtyList.size()){
-
-            minMoveCount = Math.min(minMoveCount,moveCount);
-            return true;
-        }
-
-        //반복문 돌면서 먼지를 하나씩 뽑아서 bfs돌리고 재귀호출
-        for(int i = 0; i < dirtyList.size(); i++){
-
-            //이전에 방문한 곳이라면 패스
-            if(dirtyVisited[i]) continue;
-
-            Node dirtyLoc = dirtyList.get(i);
-            int tempMove = bfs(robotLocation, dirtyLoc);
-            dirtyVisited[i] = true;
-
-            //-1이 아니면 나온 이동거리와 기존값을 더해서 리턴하도록 함.
-            if(tempMove != -1) tempMove += moveCount;
-            //재귀 호출 - false면 종료
-            if(!recursive(dirtyLoc, index + 1, tempMove)) return false;
-
-            //다음 탐색을 위해 방문처리한 위치 원복.
-            dirtyVisited[i] = false;
-
-        }
-
-        return true;
-    }
-    //로봇 위치와 먼지 찾기.
-    private static Node findRobotAndDirty(){
-
-        dirtyList = new ArrayList<>();
-
-        Node robotLocation = null;
-
-        for(int i = 0; i < H; i++){
-            for(int j = 0; j < W; j++){
-
-                if(maps[i][j] == '*'){
-                    dirtyList.add(new Node(i,j));
-                    maps[i][j] = '.';
-                }
-                if(maps[i][j] == 'o'){
-                    robotLocation = new Node(i,j);
-                    maps[i][j] = '.';
-                }
-            }
-        }
-
-        dirtyVisited = new boolean[dirtyList.size()];
-
-        //로봇 위치 반환.
-        return robotLocation;
-    }
-
-    public static void main(String[] args) throws Exception{
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st;
-
-        //최종적으로 출력할 스트링빌더
-        StringBuilder result = new StringBuilder();
-
-
-        while(true){
-
-            st = new StringTokenizer(br.readLine());
-            W = Integer.parseInt(st.nextToken());
-            H = Integer.parseInt(st.nextToken());
-
-
-            //값이 둘다 0이면 종료
-            if(W == 0 && H == 0) break;
-
-            //최소값 저장할 변수 초기화
-            minMoveCount = Integer.MAX_VALUE;
-
-            //지도 입력받기.
-            maps = new char[H][W];
-
-            for(int i = 0; i < H; i++){
-                maps[i] = br.readLine().toCharArray();
-            }
-
-            //먼지 리스트만들고, 로봇 위치 찾아서 반환.
-            Node robotLocation = findRobotAndDirty();
-
-            //재귀 호출
-            //호출해서 나온 값 저장. - 값이 안바뀌었으면 모든 더러운칸에 방문이 불가능하다는 것.
-            //재귀 호출해서 나온 값이 false이면 -1
-            if(!recursive(robotLocation.newNode(), 0, 0)){
-                result.append(-1).append("\n");
-            }
-            else{
-                result.append(minMoveCount).append("\n");
-            }
-        }
-
-        System.out.println(result);
-
-    }
-}
Index: chansik/src/week07/BOJ_16988_Baaaaaaduk2.java
===================================================================
diff --git a/chansik/src/week07/BOJ_16988_Baaaaaaduk2.java b/chansik/src/week07/BOJ_16988_Baaaaaaduk2.java
deleted file mode 100644
--- a/chansik/src/week07/BOJ_16988_Baaaaaaduk2.java	
+++ /dev/null	
@@ -1,86 +0,0 @@
-package chansik.src.week07;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-public class BOJ_16988_Baaaaaaduk2 {
-    static int[][] move = {{-1,0},{1,0},{0,1},{0,-1}};
-    static int ans;
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(bf.readLine());
-        int n = Integer.parseInt(st.nextToken());
-        int m = Integer.parseInt(st.nextToken());
-        int[][] map = new int[n][m];
-        List<int[]> posList = new ArrayList<>();
-        List<int[]> whiteList = new ArrayList<>();
-        for(int i=0;i<n;i++) {
-            st = new StringTokenizer(bf.readLine());
-            for(int j=0;j<m;j++) {
-                map[i][j] = Integer.parseInt(st.nextToken());
-                if (map[i][j] == 0) posList.add(new int[]{i, j});
-                else if (map[i][j] == 2) whiteList.add(new int[]{i,j});
-            }
-        }
-        ans = 0;
-        dfs(posList, whiteList, map, 0, 0);
-        System.out.println(ans);
-    }
-    public static  boolean isCheck(int r, int c, int n, int m) {
-        return r>=0 && r < n && c >=0 && c < m;
-    }
-
-    public static int spread(int[][] map, boolean[][] vis, int r, int c) {
-        Queue<int[]> queue = new LinkedList<>();
-        int n = map.length;
-        int m = map[0].length;
-        int count = 1;
-        boolean check = false;
-        queue.add(new int[]{r,c});
-        vis[r][c] = true;
-        while(!queue.isEmpty()) {
-            int[] info = queue.poll();
-            int cr = info[0]; int cc = info[1];
-            for(int i=0;i<4;i++) {
-                int nr = cr + move[i][0];
-                int nc = cc + move[i][1];
-                if (isCheck(nr, nc, n, m)) {
-                    if (map[nr][nc] == 0) check = true;
-                    if (!vis[nr][nc] && map[nr][nc] == 2) {
-                        vis[nr][nc] = true;
-                        queue.add(new int[]{nr, nc});
-                        count++;
-                    }
-                }
-            }
-        }
-        return check ? 0 : count;
-    }
-
-    public static int find(List<int[]> whiteList, int[][] map) {
-        boolean[][] vis = new boolean[map.length][map[0].length];
-        int sum = 0;
-        for (int[] info : whiteList) {
-            int r = info[0]; int c = info[1];
-            if (!vis[r][c]) sum += spread(map, vis, r, c);
-        }
-        return sum;
-    }
-
-    public static void dfs(List<int[]> posList, List<int[]> whiteList, int[][] map, int index, int count) {
-        if (count == 2) {
-            ans = Math.max(ans, find(whiteList, map));
-            return;
-        }
-
-        for(int i=index;i<posList.size();i++) {
-            int[] info = posList.get(i);
-            int r = info[0]; int c = info[1];
-            map[r][c] = 1;
-            dfs(posList, whiteList, map, i+1, count + 1);
-            map[r][c] = 0;
-        }
-    }
-}
Index: README.md
===================================================================
diff --git a/README.md b/README.md
deleted file mode 100644
--- a/README.md	
+++ /dev/null	
@@ -1,25 +0,0 @@
-<h1 align="center"> <img src="https://github.com/escape-study/algorithm/assets/56991244/34494fd6-be31-479e-bc04-f9944d96cead"> </h1>
-
-------
-
-# ✏️ **코테 대비 알고리즘 인증 스터디**
-
-------
-
-* 매주 4문제 풀고 `각자의 깃허브 닉네임` 으로 된 브랜치에 push
-* 매주 월요일 5층에서 문제 정하기.
-
-* [**커밋 메시지 작성 규칙**](https://github.com/escape-study/algorithm/wiki/Commit-Message-Rule)
-
-* [**문제 선정 규칙**](https://github.com/escape-study/algorithm/wiki/%EB%AC%B8%EC%A0%9C-%EC%84%A0%EC%A0%95)
-
-| |**1**|**2**|**3**|**4**|
-|:-:|:-:|:-:|:-:|:-:|
-|1주차(23.08.07 ~ 23.08.13)|[BOJ1106 호텔](https://www.acmicpc.net/problem/1106)|[BOJ9663 N-Queen](https://www.acmicpc.net/problem/9663)|[BOJ21608 상어 초등학교](https://www.acmicpc.net/problem/21608)|[BOJ3020 개똥벌레](https://www.acmicpc.net/problem/3020)|
-|2주차(23.08.14 ~ 23.08.20)|[BOJ9251 LCS](https://www.acmicpc.net/problem/9251)|[BOJ6087 레이저](https://www.acmicpc.net/problem/6087)|[BOJ11559 puyo puyo](https://www.acmicpc.net/problem/11559)|[BOJ2470 두 용액](https://www.acmicpc.net/problem/2470)|
-|3주차(23.08.21 ~ 23.08.27)|[BOJ1520 내리막길](https://www.acmicpc.net/problem/1520)|[BOJ2589 보물섬](https://www.acmicpc.net/problem/2589)|[BOJ3190 뱀](https://www.acmicpc.net/problem/3190)|[BOJ1306 달려라 홍준](https://www.acmicpc.net/problem/1306)|
-|4주차(23.08.28 ~ 23.09.03)|[BOJ15486 퇴사2](https://www.acmicpc.net/problem/15486)|[BOJ2580 스도쿠](https://www.acmicpc.net/problem/2580)|[BOJ16236 아기상어](https://www.acmicpc.net/problem/16236)|[BOJ20437 문자열 게임2](https://www.acmicpc.net/problem/20437)|
-|5주차(23.09.04 ~ 23.09.10)|[BOJ2011 암호코드](https://www.acmicpc.net/problem/2011)|[BOJ16987 계란으로 계란치기](https://www.acmicpc.net/problem/16987)|[BOJ17281 ⚾](https://www.acmicpc.net/problem/17281)|[BOJ2812 크게 만들기](https://www.acmicpc.net/problem/2812)|
-|6주차(23.09.11 ~ 23.09.17)|[BOJ2504 괄호의 값](https://www.acmicpc.net/problem/2504)| [BOJ1937 욕심쟁이 판다](https://www.acmicpc.net/problem/1937) | [BOJ2138 전구와 스위치](https://www.acmicpc.net/problem/2138) | [BOJ4991 로봇 청소기](https://www.acmicpc.net/problem/4991)|
-|7주차(23.09.18 ~ 23.09.24)|[BOJ16988 Baaaaaaaaaduk2 (Easy)](https://www.acmicpc.net/problem/16988)|[BOJ2212 센서](https://www.acmicpc.net/problem/2212)|[BOJ18809 Gaaaaaaaarden](https://www.acmicpc.net/problem/18809)|[BOJ2143 두 배열의 합](https://www.acmicpc.net/problem/2143)|
-|8주차(23.09.25 ~ 23.10.01)|[BOJ7576 토마토](https://www.acmicpc.net/problem/7576)|[BOJ17485 진우의 달 여행 (Large)](https://www.acmicpc.net/problem/17485)|[BOJ16235 나무 재테크](https://www.acmicpc.net/problem/16235)|[BOJ1062 가르침](https://www.acmicpc.net/problem/1062)|
Index: minjae/week5/BOJ_17281_야구.java
===================================================================
diff --git a/minjae/week5/BOJ_17281_야구.java b/minjae/week5/BOJ_17281_야구.java
deleted file mode 100644
--- a/minjae/week5/BOJ_17281_야구.java	
+++ /dev/null	
@@ -1,160 +0,0 @@
-package week5;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.Arrays;
-import java.util.StringTokenizer;
-
-public class BOJ_17281_야구 {
-    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-    static StringTokenizer st;
-
-    static int N , Min, Max, M , K, X , P;
-    static int Map[][];
-    static boolean checked[];
-
-    static int delta[][] = {{0,1},{0,-1},{1,0},{-1,0},{0,0}};
-    public static void main(String[] args) throws NumberFormatException, IOException {
-        // TODO Auto-generated method stub
-        N = Integer.parseInt(br.readLine());
-
-        Map = new int[N+1][10];
-        checked = new boolean[10];
-        Max = Integer.MIN_VALUE;
-
-        for (int i = 1; i <= N ; i++) {
-            st = new StringTokenizer(br.readLine());
-            for (int j = 1; j <= 9; j++) {
-                Map[i][j] = Integer.parseInt(st.nextToken());
-            }
-        }
-
-        int order[] = new int[10];
-        order[4] = 1;
-        checked[1] = true;
-        sequence(1 , order );
-        System.out.println(Max);
-    }
-
-    static public void sequence(int cnt , int order[]){
-        if(cnt == 10){ // 끝
-            Max = Math.max( culculate(order) , Max);
-            return;
-        }
-        if(cnt == 4){
-            sequence(cnt+1 ,order);
-        }else{
-            for (int i = 2; i <= 9 ; i++) {
-                if(!checked[i]){
-                    checked[i] = true;
-                    order[cnt] = i;
-                    sequence(cnt+1 , order);
-                    checked[i] = false;
-                }
-            }
-
-        }
-
-
-
-
-    }
-
-    static public int culculate(int[] order){
-        int idx = 1;
-        int sum = 0;
-        for(int i = 1; i <= N ; i++){
-            int out = 0;
-            int l[] = new int[5];
-            int inningScore = 0;
-            boolean[] base = new boolean[4];
-
-
-            while(out < 3) {
-                switch(Map[i][order[idx]]) {
-                    // 아웃
-                    case 0:
-                        out++;
-                        break;
-                    // 1루타
-                    case 1:
-                        if(base[3]) {
-                            inningScore++;
-                            base[3] = false;
-                        }
-                        if(base[2]) {
-                            base[3] = true;
-                            base[2] = false;
-                        }
-                        if(base[1]) {
-                            base[2] = true;
-                        }
-                        base[1] = true;
-                        break;
-                    // 2루타
-                    case 2:
-                        if(base[3]) {
-                            inningScore++;
-                            base[3] = false;
-                        }
-                        if(base[2]) {
-                            inningScore++;
-                        }
-                        if(base[1]) {
-                            base[3] = true;
-                            base[1] = false;
-                        }
-                        base[2] = true;
-                        break;
-                    // 3루타
-                    case 3:
-                        if(base[3]) {
-                            inningScore++;
-                        }
-                        if(base[2]) {
-                            inningScore++;
-                            base[2] = false;
-                        }
-                        if(base[1]) {
-                            inningScore++;
-                            base[1] = false;
-                        }
-                        base[3] = true;
-                        break;
-                    // 홈런
-                    case 4:
-                        if(base[3]) {
-                            inningScore++;
-                            base[3] = false;
-                        }
-                        if(base[2]) {
-                            inningScore++;
-                            base[2] = false;
-                        }
-                        if(base[1]) {
-                            inningScore++;
-                            base[1] = false;
-                        }
-                        inningScore++;
-                        break;
-                }
-
-                // 다음 타자로
-                idx++;
-                // 만약 10번 타자가 되면 다시 1번 타자로 되돌림
-                if(idx >= 10) {
-                    idx = 1;
-                }
-            }
-
-            // 해당 이닝에서 얻은 점수를 총 게임 점수에 더해줌
-            sum += inningScore;
-
-        }
-
-
-        return sum;
-    }
-
-}
\ No newline at end of file
Index: minjae/week7/BOJ_16988_Baaaaaaaaaduk2.java
===================================================================
diff --git a/minjae/week7/BOJ_16988_Baaaaaaaaaduk2.java b/minjae/week7/BOJ_16988_Baaaaaaaaaduk2.java
deleted file mode 100644
--- a/minjae/week7/BOJ_16988_Baaaaaaaaaduk2.java	
+++ /dev/null	
@@ -1,100 +0,0 @@
-package week7;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-public class BOJ_16988_Baaaaaaaaaduk2 {
-    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-    static StringTokenizer st;
-
-    static int N , M , Map[][] ,delta[][] = {{1,0},{0,1}, {-1,0},{0,-1}} , Max;
-
-
-    public static void main(String[] args) throws IOException {
-
-        st = new StringTokenizer(br.readLine());
-        N = Integer.parseInt(st.nextToken());
-        M = Integer.parseInt(st.nextToken());
-        Map = new int[N][M];
-
-        for (int i = 0; i < N; i++) {
-            st = new StringTokenizer(br.readLine());
-            for (int j = 0; j < M; j++) {
-                Map[i][j] = Integer.parseInt(st.nextToken());
-            }
-        }
-
-        find(0,2);
-        System.out.println(Max);
-
-    }
-    static public void find(int cnt , int num){
-        if(num == 0){
-            group();
-            return;
-        }
-        if(cnt == N*M){ // 종료
-            return;
-        }
-
-        int h = cnt / M;
-        int r = cnt % M;
-
-        if(Map[h][r] == 0){
-            Map[h][r] = 1;
-            find(cnt+1 , num-1);
-            Map[h][r] = 0;
-        }
-        find(cnt+1,num);
-    }
-
-    static public void group(){
-
-        boolean checked[][] = new boolean[N][M];
-        int sum = 0;
-
-        for(int i = 0 ; i < N ;i++){
-            for (int j = 0; j < M; j++) {
-                if(Map[i][j] == 2 && !checked[i][j]){
-                    sum += bfs(i, j , checked);
-                }
-            }
-        }
-        Max = Math.max(Max, sum);
-    }
-
-    private static int bfs(int h, int r, boolean[][] checked) {
-        Queue<int []> queue = new LinkedList<>();
-        queue.add(new int[]{h, r});
-        checked[h][r] = true;
-        int num = 1;
-
-        boolean flag = false;
-
-        while (!queue.isEmpty()){
-            int now[] = queue.poll();
-
-            for(int i = 0 ; i < delta.length ;i++){
-                int x = now[0] + delta[i][0];
-                int y = now[1] + delta[i][1];
-
-                if(x < 0 || x >= N || y <0 || y >= M || checked[x][y] || Map[x][y] == 1) continue;
-                if(Map[x][y] == 2){
-                    queue.add(new int[]{x,y});
-                    checked[x][y] = true;
-                    num++;
-                }else if(Map[x][y] == 0){
-                    flag = true;
-                }
-            }
-
-        }
-
-        return flag?0:num;
-
-    }
-
-
-}
\ No newline at end of file
Index: soyeonLim/week08/BOJ_1062_가르침.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/soyeonLim/week08/BOJ_1062_가르침.java b/soyeonLim/week08/BOJ_1062_가르침.java
new file mode 100644
--- /dev/null	
+++ b/soyeonLim/week08/BOJ_1062_가르침.java	
@@ -0,0 +1,101 @@
+package week08;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.StringTokenizer;
+
+public class BOJ_1062_가르침 {
+    /*
+        예제 :
+        9 8
+        antabtica  >> data[0] = b
+        antaxtica  >> data[1] = x
+        antadtica  >> data[2] = d
+        antaetica  >> data[3] = e
+        antaftica  >> data[4] = f
+        antagtica  >> data[5] = g
+        antahtica  >> data[6] = h
+        antajtica  >> data[7] = j
+        antaktica  >> data[8] = k
+     */
+    public static int N,K;
+    public static String[] data;
+    public static int answer;
+
+    public static void main(String[] args) throws IOException
+    {
+        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+        StringTokenizer st = new StringTokenizer(br.readLine());
+        N = Integer.parseInt(st.nextToken());
+        K = Integer.parseInt(st.nextToken());
+
+        int mask =0;
+        // a 1, c 3, i 9, n 14, t 20
+        mask |= 1 << (int)'a'-96;//(2^1)
+        mask |= 1 << (int)'c'-96;//(2^1+2^3)
+        mask |= 1 << (int)'i'-96;//(2^1+2^3+2^9)
+        mask |= 1 << (int)'n'-96;//(2^1+2^3+2^9+2^14)
+        mask |= 1 << (int)'t'-96;//(2^1+2^3+2^9+2^14+2^20)
+
+        data = new String[N];
+        for(int i=0;i<N;i++)
+        {
+            String s = br.readLine();
+            s = s.replaceAll("[a,c,i,n,t]","");
+            data[i]=s;
+        }
+
+        dfs(1,5,mask);
+        System.out.println(answer);
+    }
+
+    public static void dfs(int start, int depth,int mask)
+    {
+        if(K<5)
+        {
+            answer =0;
+            return;
+        }
+        if(K>=26)
+        {
+            answer=N;
+            return;
+        }
+        if(depth==K){
+            int num =0;
+            for(int i=0;i<N;i++)
+            {
+                boolean check =true;
+                //data와 비교해서 있는지 확인
+                for(int j=0;j<data[i].length();j++)
+                {
+                    if((mask &(1<<data[i].charAt(j)-96))==0)
+                    {
+                        check=false;
+                        break;
+                    }
+                }
+                if(check) num++;
+            }
+            answer = Math.max(answer, num);
+            return;
+        }
+        /*
+        a,c,i,n,t가 있으므로 mask : 100000100001000001010
+        i==2 : 100000100001000001110 > a,b,c,i,n,t
+        i==4 : 100000100001000011110 > a,b,c,d,i,n,t
+        i==5 : 100000100001000111110 > a,b,c,d,e,i,n,t >> 8개 이므로 갯수 구하기 b,d,e 있으므로 answer =3
+
+        i==6 : 100000100001001011110 > a,b,c,d,f,i,n,t >> b,d,f 있으므로 answer =3
+         */
+        for(int i=start;i<27;i++)
+        {
+            //mask 안에 안 들어있을 경우
+            if((mask & (1<<i))==0)
+            {
+                dfs(i+1,depth+1,mask|(1<<i));
+            }
+        }
+    }
+}
